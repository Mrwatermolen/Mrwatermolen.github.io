<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="MH&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="MH&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="MH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>MH's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MH's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/" class="post-title-link" itemprop="url">机器学习笔记四：无监督学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-17 16:45:50" itemprop="dateCreated datePublished" datetime="2021-08-17T16:45:50+08:00">2021-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>无监督学习是根据类别未知的训练样本解决模式识别中的各种问题</p>
<h2 id="类聚问题Cluster"><a href="#类聚问题Cluster" class="headerlink" title="类聚问题Cluster"></a>类聚问题Cluster</h2><p>给定m个未标记的数据集，对其进行分类。使得簇内数据之间具有高的相似性；不同簇数据之间具有高的差异性。</p>
<h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><p>基于划分的聚类方法，以空间中k个点为中心进行聚类，对最靠近他们的对象归类，不断迭代计算，更新中心点，使得代价最小。</p>
<p>对m个维度为n的数据集</p>
<p>K-means执行步骤：</p>
<p>随机初始化类聚中心：</p>
<p>Randomly initialize K cluster centroids<br>$$<br>\mu_1,u_2,\cdots,u_k\in R^n<br>$$<br>Repeat:</p>
<p>对每个样本数据$x_i$选择距离其最近的类别中心<br>$$<br>c_i = index(1 \to K); of; cluster; centroid; closest; x_i=arg\min_{1\le j\le k}||x_i-\mu_j||<br>$$<br>更新类别中心：<br>$$<br>\mu_j = \frac{1}{|c_j|}\sum_{i\in c_j}x_i<br>$$<br>Until :<br>$$<br>|\mu_j-\mu_j’|\le\epsilon<br>$$<br>其代价函数为：<br>$$<br>J(\mu)=\frac{1}{m}\sum_{i=1}^m||x_i-\mu_{c_i}||^2<br>$$<br>求其对$\mu_j$的偏导时期为零，有：<br>$$<br>\mu_j = \frac{1}{|c_j|}\sum_{i\in c_j}x_i<br>$$<br>当运行K-means的时候，需要有K个聚类中心值，其中K值要比训练样本的数量m小。其中初始化聚类中心这一步十分的重要，如果初始化不好，会造成产生局部最优的结果。</p>
<p>运行多次K-means算法，比较代价函数，选取代价最小的。</p>
<p>类别中心的数目的选择</p>
<ol>
<li><p>肘部法则：其中需要做的就是改变K的值，然后运行K-means算法，最后计算代价函数。重复改变K的值按照同样的方法运行，就会得到一条曲线。一般会得到一条曲线，随着K值的不断增加，代价函数的值快速下降，超过某个值后代价函数的下降速度变慢。</p>
</li>
<li><p>实际</p>
</li>
</ol>
<h3 id="k-means算法优缺点对比"><a href="#k-means算法优缺点对比" class="headerlink" title="k-means算法优缺点对比"></a>k-means算法优缺点对比</h3><p><strong>优点</strong>：</p>
<ol>
<li>是解决聚类问题的一种经典算法，简单、快速。它的时间复杂度为$O(t\cdot n \cdot k)$其中t为迭代次数，n为样本数，k为所需划分簇的数目。</li>
<li>对处理大数据集，该算法保持可伸缩性和高效性。</li>
<li>当簇近似为高斯分布时，它的效果较好。</li>
</ol>
<p>   <strong>缺点</strong>：</p>
<ol>
<li>在簇的平均值可被定义的情况下才能使用，可能不适用于某些应用。</li>
<li>必须实现给出k(要生成的簇的数目)，而且对初值敏感，对于不同的初始值，可能会导致不同结果。</li>
<li>不适用于发现非凸形状的簇或者大小差别很大的簇。</li>
<li>因为求取的是均值，所以其对噪声和孤立点数据敏感。 其可作为其它算法的基础，如谱聚类。</li>
</ol>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>将高维的数据通过各种方法降低到低维空间中，也是一种无监督学习问题。</p>
<h3 id="PCA主成分分析"><a href="#PCA主成分分析" class="headerlink" title="PCA主成分分析"></a>PCA主成分分析</h3><p>对高维数据寻找一个低维空间，将数据全部投影到该空间上，使投影的误差最小。</p>
<p>步骤：</p>
<ol>
<li><p>预处理数据，均值归一化</p>
</li>
<li><p>计算协方差矩阵<br>$$<br>\Sigma=\frac{1}{m}\sum_{i=1}^mx_ix_i^T<br>$$</p>
</li>
<li><p>对协方差矩阵进行奇异分解<br>$$<br>svd(\Sigma)=[U,S,V]<br>$$</p>
</li>
<li><p>取矩阵U中的前k列<br>$$<br>U_{reduce}=[u_1,u_2,u_3,\cdots,u_k]^T<br>$$</p>
</li>
<li><p>高维数据投影到低维空间用坐标变换式子可得：<br>$$<br>z_i=U_{reduce}^T\cdot x_i<br>$$</p>
</li>
</ol>
<p>值得注意的是：<br>$$<br>U_{reduce}^T\cdot U_{reduce}=E<br>$$<br>那么已知低维空间的一个数据，也可将其近似复现于高维空间中<br>$$<br>x_{approx}=U_{reduce}\cdot z<br>$$<br>而这里的k值，被称为主成分数量。</p>
<h3 id="主成分数量选择"><a href="#主成分数量选择" class="headerlink" title="主成分数量选择"></a>主成分数量选择</h3><p>PCA是使得平均投影误差最小，即：<br>$$<br>\min \frac{1}{m}\sum_{i=1}^m||x_i-x_i^{approx}||^2<br>$$<br>k值的选取：</p>
<p>选取最小的k值使得：<br>$$<br>\frac{\frac{1}{m}\sum_{i=1}^m||x_i-x_i^{approx}||^2}{\frac{1}{m}\sum_{i=1}^m||x_i||^2}\le 0.01<br>$$<br>即保留99%的差异（99% of variance be retained）</p>
<p>当然也可以保留95%，90%。</p>
<p>上式等价于<br>$$<br>1-\frac{\frac{1}{k}\sum_{i=1}^ks_{ii}}{\frac{1}{n}\sum_{i=1}^ns_{ii}}\le 0.01<br>$$</p>
<p>$$<br>s_{ii}\in S<br>$$</p>
<p>奇异分解得到的S矩阵是对角矩阵，对角线上的元素为协方差矩阵的特征值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/21/KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/21/KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-21 22:58:58" itemprop="dateCreated datePublished" datetime="2021-07-21T22:58:58+08:00">2021-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> **KMP算法目的:**快速从主串中匹配出与模式串相同的子串</p>
<p>在梳理之前，先给几个约定吧。</p>
<ul>
<li><p>语言：C++</p>
</li>
<li><p>字符串s，其子串的表示方法s[i]~[j]</p>
</li>
<li><p>默认已经了解KMP算法中的一些基本概念，如主串，模式串等。</p>
</li>
<li><p>证明并不严谨，只是呢，个人感觉如果知道了证明，就能够掌握住KMP算法的精髓</p>
</li>
<li><p>本文的举例子都挺辣眼睛的，就是方便理解，可不看，重要的是证明。</p>
</li>
</ul>
<h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute-Force"></a>Brute-Force</h2><p>在说明KMP算法前，不得不先了解一下暴力算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;mainString, <span class="keyword">const</span> <span class="built_in">string</span> &amp;modeString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modeString == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mainString.length() &lt; modeString.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mainString.length() &amp;&amp; j &lt; modeString.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mainString[i] == modeString[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++k;</span><br><span class="line">            i = k;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= modeString.length())</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次匹配不成功，我们都把主串游标和模式串游标移动回来。时间复杂度为$O(mn)$</p>
<h2 id="KMP算法的理解"><a href="#KMP算法的理解" class="headerlink" title="KMP算法的理解"></a>KMP算法的理解</h2><p>首先明白暴力算法的过程与原理，先直接上KMP算法的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;mainString, <span class="keyword">const</span> <span class="built_in">string</span> &amp;modeString)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modeString == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (mainString.length() &lt; modeString.length())</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = GetNext(needle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modeStrLen = modeString.length(), mainStrLen = mainString.length(); <span class="comment">//由于length()返回的是一个无符号的整形数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int，则表达式s.length() &lt; n的判断结果几乎肯定是true</span></span><br><span class="line">        <span class="keyword">int</span> modeIndex = <span class="number">0</span>, mainIndex = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//KMP</span></span><br><span class="line">        <span class="keyword">while</span> (modeIndex &lt; modeStrLen &amp;&amp; mainIndex &lt; mainStrLen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (modeIndex == <span class="number">-1</span> || mainString[mainIndex] == modeString[modeIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                ++modeIndex, ++mainIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                modeIndex = next[modeIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modeIndex == modeStrLen)</span><br><span class="line">            <span class="keyword">return</span> mainIndex - modeIndex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;modeString)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mainIndex = <span class="number">0</span>, pairIndex = <span class="number">-1</span>, length = modeString.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(length)</span></span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//next的求法其实也就是进行一次对自己的KMP</span></span><br><span class="line">        <span class="keyword">while</span> (mainIndex &lt; length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairIndex == <span class="number">-1</span> || modeString[mainIndex] == modeString[pairIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                ++mainIndex, ++pairIndex;</span><br><span class="line">                next[mainIndex] = pairIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pairIndex = next[pairIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>KMP算法是一个很精妙的算法，其关键在于next数组，但next数组的获取又涉及KMP算法，因为next的获取其实也就是进行一次对modeString的KMP，所以如果先讲next数组，在讲KMP算法，可能效果不太好。我们先弄清楚KMP的运行逻辑与过程，然后再说明next数组的逻辑，再证明KMP算法的正确性。</p>
<h3 id="KMP算法的运行逻辑与过程"><a href="#KMP算法的运行逻辑与过程" class="headerlink" title="KMP算法的运行逻辑与过程"></a>KMP算法的运行逻辑与过程</h3><p>其实如果你已经理解KMP算法的运行逻辑与过程，那就大可不必看这一部分内容，直接看提炼总结即可。因为下面的说明实在是太啰嗦了。</p>
<h4 id="公共前后缀"><a href="#公共前后缀" class="headerlink" title="公共前后缀"></a>公共前后缀</h4><p>next数组是理解KMP的核心所在，但我们这里先不去理解next数组是怎么来的，也就是不要先去管<strong>GetNext函数</strong>， 我们只要先明白next数组的含义即可。</p>
<p>在此之前先理解一个很简单的概念<strong>公共前后缀</strong>。</p>
<p>先给出定义，定义可以看一下，看例子就能很好理解了。</p>
<ul>
<li>前缀：是指不包含最后一个字符的所有以第一个字符开头的连续子串</li>
<li>后缀：是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li>
<li>公共前后缀：是指前缀==后缀</li>
</ul>
<p>例子一：s = “a”，s没有前缀，也没有后缀，公共前后缀也没有，可以理解为“”</p>
<p>例子二：s = “ab”，s的前缀：”a”，s的后缀：”b”，没有公共前后缀</p>
<p>例子三：s = “aaabaa”，s的前缀：”a”、”aa”、”aaa”、”aaab”、”aaaba”，s的后缀：”a”、”aa”、”baa”、”abaa”、”aabaa”，公共前后缀：”a”、”aa”。</p>
<p><strong>next[j]的含义：modeString[0]~[j-1]的最长公共前后缀的长度</strong></p>
<p><strong>当模式串modeString[j]与mainString[i]匹配失败时，模式串要检查modeString[next[j]]与mainString[i]是否匹配</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ()</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (modeString[j] == mainString[i])</span><br><span class="line">          &#123;</span><br><span class="line">              ++i, ++j;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              j = next[j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>无论有何种疑惑，总之请先记牢上面两行加粗的字即可。</p>
<h4 id="模拟推演KMP算法的运行"><a href="#模拟推演KMP算法的运行" class="headerlink" title="模拟推演KMP算法的运行"></a>模拟推演KMP算法的运行</h4><p>我们只关注<strong>Index</strong>函数即可。</p>
<p>设</p>
<p>主串为mainString = “FABDABABCAB”</p>
<p>模式串为modeString = “ABCAB”</p>
<table>
<thead>
<tr>
<th>next数组</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>next[0]</td>
<td>-1</td>
</tr>
<tr>
<td>next[1]</td>
<td>0</td>
</tr>
<tr>
<td>next[2]</td>
<td>0</td>
</tr>
<tr>
<td>next[3]</td>
<td>0</td>
</tr>
<tr>
<td>next[4]</td>
<td>1</td>
</tr>
</tbody></table>
<p>按照定义都可以手算出next数组，不过一个特殊的点是对next[0]，显然不存在modeString[0]~[-1]，可能我们一开始会设置为0，但是设置为-1更好。next[0] = -1也是一个暂时要死记的点。</p>
<p>主逻辑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">int</span> modeIndex = <span class="number">0</span>, mainIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (modeIndex &lt; modeStrLen &amp;&amp; mainIndex &lt; mainStrLen)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (modeIndex == <span class="number">-1</span> || mainString[mainIndex] == modeString[modeIndex])</span><br><span class="line">          &#123;</span><br><span class="line">              ++modeIndex, ++mainIndex;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              modeIndex = next[modeIndex];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">比较mainString[0] &#x3D;&#x3D; modeString[0]; &#39;F&#39; &#x3D;&#x3D; &#39;A&#39;;</span><br><span class="line"></span><br><span class="line">​	 modeIndex &#x3D; next[modeIndex]; modeIndex &#x3D; -1;</span><br><span class="line"></span><br><span class="line">modeIndex &#x3D;&#x3D; -1</span><br><span class="line"></span><br><span class="line">​	++modeIndex, ++mainIndex; modeIndex &#x3D; 0, mainIndex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">比较mainString[1] &#x3D;&#x3D; modeString[0]; &#39;A&#39; &#x3D;&#x3D; &#39;A&#39;;</span><br><span class="line"></span><br><span class="line">​	++modeIndex, ++mainIndex; modeIndex &#x3D; 1, mainIndex &#x3D; 2;</span><br><span class="line"></span><br><span class="line">比较mainString[2] &#x3D;&#x3D; modeString[1]; &#39;B&#39; &#x3D;&#x3D; &#39;B&#39;;</span><br><span class="line"></span><br><span class="line">​	++modeIndex, ++mainIndex; modeIndex &#x3D; 2, mainIndex &#x3D; 3;</span><br><span class="line"></span><br><span class="line">比较mainString[3] &#x3D;&#x3D; modeString[2]; &#39;D&#39; &#x3D;&#x3D; &#39;C&#39;;</span><br><span class="line"></span><br><span class="line">​	modeIndex &#x3D; next[modeIndex]; modeIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">比较mainString[3] &#x3D;&#x3D; modeString[0]; &#39;D&#39; &#x3D;&#x3D; &#39;A&#39;;</span><br><span class="line"></span><br><span class="line">​	modeIndex &#x3D; next[modeIndex]; modeIndex &#x3D; -1;</span><br><span class="line"></span><br><span class="line">省略</span><br><span class="line"></span><br><span class="line">比较mainString[6] &#x3D;&#x3D; modeString[2]; &#39;A&#39; &#x3D;&#x3D; &#39;C&#39;;</span><br><span class="line"></span><br><span class="line">​	modeIndex &#x3D; next[modeIndex]; modeIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">比较mainString[6] &#x3D;&#x3D; modeString[0]; &#39;A&#39; &#x3D;&#x3D; &#39;A&#39;;</span><br><span class="line"></span><br><span class="line">之后一路比对成功</span><br><span class="line"></span><br><span class="line">跳出循环 mainIndex &#x3D; 11, modeIndex &#x3D; 5</span><br><span class="line"></span><br><span class="line">KMP是否在主串中找到模式串的逻辑是相同的都是判断是否遍历完毕了模式串。</span><br><span class="line"></span><br><span class="line">那么在6那儿相等</span><br></pre></td></tr></table></figure>



<h4 id="解释运行逻辑"><a href="#解释运行逻辑" class="headerlink" title="解释运行逻辑"></a>解释运行逻辑</h4><p>手动去模拟完毕后，我们能有很多发现。</p>
<p>可以发现mainIndex只会增加，而不是像暴力算法那样会把mainIndex往回移动。</p>
<p>modeIndex的往回移动是基于next数组的。</p>
<p><strong>next[j]的含义：modeString[0]~[j-1]的最长公共前后缀的长度</strong></p>
<p><strong>当模式串modeString[j]与mainString[i]匹配失败时，模式串要检查modeString[next[j]]与mainString[i]是否匹配</strong></p>
<p>我们在看一个例子，再一次深刻了解next数组的作用</p>
<p>主串：”AABAACAABAAD”</p>
<p>模式串：”AABAAD”</p>
<p>假设此时判断到”C”==”D”，匹配失败了。</p>
<p>按照暴力算法，我们要重新匹配”ABAACAABAAD”与”AABAAD”，但我们有next数组，它告诉我们应该判断”C”==”B”，因为”AABAAC“与”AABAAD”中前面匹配成功的”AABAA”最长公共前后缀的长度为2，我们就把问题匹配”AABAAC“与”AABAAD”，变成了匹配”AAC“与”AAB”</p>
<p><strong>也就是说我们可以把公共前缀和公共后缀对齐，继续往下比较，而不用往回移动mainIndex，如果没有公共前后缀，那么modeIndex=0或-1；也就说前面的都不匹配了，模式串要从头匹配，如果头也不匹配，那么我们就丢弃，那么主串的游标就要往后走。</strong></p>
<p>0和-1也是一个很妙的处理，首先明确只有next[0]能得到-1。我们继续上面的”AAC“与”AAB”，’C’与’B’也不匹配，’C’与modeString[1]=’A’也不匹配，’C’与modeString[0]=’A’也不匹配，所以我们不能继续匹配’C’了必须将其跳过，所以跳过条件modeIndex == -1，刚刚好-1+1 = 0，则继续新的匹配。</p>
<h4 id="提炼总结"><a href="#提炼总结" class="headerlink" title="提炼总结"></a>提炼总结</h4><p>其实最关键的就是next数组，也就是说，如果在某个位置匹配k失败的时候，我们可以知道[0]~[k-1]的字符串里的最长公共前后缀，我们就可以把模式串的最长公共前缀以及主串的最长公共后缀<strong>对齐</strong>起来，然后再匹配即可。</p>
<p>容我再啰嗦一句，这个对齐操作。理解起来很简单，上个例子即可</p>
<p>“ABCABDABCABF”</p>
<p>“ABCABF”</p>
<p>在判断’D’==’F’时失败了，重新对齐最长公共前后缀，next[5] = 2</p>
<p>“ABCABDABCABF”</p>
<p>​        “ABCABF”</p>
<p>此时判断’D’==’F’</p>
<p>关键的关键点就是next数组引导了对齐操作。</p>
<p>好嘛，正好此时就能引出next数组了。</p>
<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>先上求next数组的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;modeString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mainIndex = <span class="number">0</span>, pairIndex = <span class="number">-1</span>, length = modeString.length();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(length)</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//next的求法其实也就是进行一次对自己的KMP</span></span><br><span class="line">    <span class="keyword">while</span> (mainIndex &lt; length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pairIndex == <span class="number">-1</span> || modeString[mainIndex] == modeString[pairIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            ++mainIndex, ++pairIndex;</span><br><span class="line">            next[mainIndex] = pairIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pairIndex = next[pairIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是KMP算法的精髓之精髓所在了。为什么自身进行KMP能得到next数组呢？</p>
<h3 id="next数组的证明"><a href="#next数组的证明" class="headerlink" title="next数组的证明"></a>next数组的证明</h3><p>首先无论如何，有两个固定的值。</p>
<p>next[0] = -1, next[1] = 0;</p>
<p>下面就上数学证明了。</p>
<p>我们要证明：在运行完毕上述代码后，得到的next数组满足<strong>next[i]的定义：modeString[0]~[i-1]的最长公共前后缀的长度</strong></p>
<p>证：</p>
<p>我们记pairIndex是以自身为模式串的要与主串匹配的游标的位置,mainIndex是以自身为主串的要与模式串匹配游标的位置。（又开始啰嗦了。）</p>
<p>且<br>$$<br>\text{i = 0,next[i] = -1}<br>$$</p>
<p>$$<br>\text{i = 1,next[i] = 0}<br>$$</p>
<p>此时next满足定义。</p>
<p>当：<br>$$<br>\text{i&gt;=2}<br>$$<br>我们有已知<br>$$<br>\text{next[0]$\backsim$next[i-1]}<br>$$<br>都是满足next数组的定义的。</p>
<p>那么已知next[i-1]意味着我们已经知道modeString[0]~[i-2]的最长公共前后缀的长度</p>
<p>可设<br>$$<br>\text{next[i-1]=k}<br>$$<br>必然有：<br>$$<br>\text{modeString[i-1-k]$\backsim$[i-2] == modeString[0]$\backsim$[k-1]}<br>$$<br>那么为了求出next[i]，我们先对齐对齐模式串的前缀以及主串的后缀令<br>$$<br>\text{pairIndex=k,mainIndex=i-1}<br>$$<br>然后判断<br>$$<br>\text{? modeString[mainIndex] == modeString[pairIndex]}<br>$$</p>
<p>如果不匹配：<br>$$<br>\text{modeString[mainIndex] != modeString[pairIndex]}<br>$$<br>重新对齐模式串的前缀以及主串的后缀，即令pairIndex = next[pairIndex]，直至匹配或者pairIndex = -1意味着没有公共前后缀。</p>
<p>如果匹配：<br>$$<br>\text{modeString[mainIndex] == modeString[pairIndex]}<br>$$</p>
<p>$$<br>\to\text{[0]$\backsim$[mainIndex]的最长公共前后缀的长度为pairIndex+1}<br>$$</p>
<p>即<br>$$<br>\text{next[i]=最后更新的pairIndex加上1}<br>$$<br>此时next[i]满足定义。</p>
<p>由数学归纳法，经上述步骤后所求的next一定满足定义</p>
<p>把上面的数学推导转化成代码就是求出next数组的代码。</p>
<p>得证。</p>
<h3 id="KMP算法的证明"><a href="#KMP算法的证明" class="headerlink" title="KMP算法的证明"></a>KMP算法的证明</h3><p>把next数组的正确性证明完毕后，终于算是理解了KMP算法了，KMP算法的难以理解的地方就是在于next数组的求出与KMP算法的是互相交叉的，先讲KMP算法，就容易被next数组绕晕，先讲next数组，就容易一头雾水为什么要这样求。</p>
<p>好嘛，我们已经得到了一个关于模式串的next数组。再一次搬出next数组的定义</p>
<p>next数组满足<strong>next[i]的定义：modeString[0]~[i-1]的最长公共前后缀的长度</strong></p>
<p>再附上KMP算法的主逻辑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> modeIndex = <span class="number">0</span>, mainIndex = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//KMP</span></span><br><span class="line">   <span class="keyword">while</span> (modeIndex &lt; modeStrLen &amp;&amp; mainIndex &lt; mainStrLen)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (modeIndex == <span class="number">-1</span> || mainString[mainIndex] == modeString[modeIndex])</span><br><span class="line">       &#123;</span><br><span class="line">           ++modeIndex, ++mainIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           modeIndex = next[modeIndex];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (modeIndex == modeStrLen)</span><br><span class="line">       <span class="keyword">return</span> mainIndex - modeIndex;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>证：</p>
<p>（1）</p>
<p>当：<br>$$<br>\text{modeIndex = -1}<br>$$<br>可得：<br>$$<br>\text{mainString[mainIndex] != modeString[0]}<br>$$<br>此时要判断<br>$$<br>\text{? mainString[mainIndex+1] == modeString[0]}<br>$$<br>（2）</p>
<p>当：<br>$$<br>\text{modeIndex $\neq$ -1}<br>$$<br>如果匹配：<br>$$<br>\text{ mainString[mainIndex] == modeString[modeIndex]}<br>$$<br>则继续往下判断：<br>$$<br>\text{? mainString[mainIndex+1] == modeString[modeIndex+1]}<br>$$<br>如果不匹配：<br>$$<br>\text{ mainString[mainIndex] != modeString[modeIndex]}<br>$$<br>我们已知next[modeIndex]，即可设<br>$$<br>\text{next[modeIndex]=k$\neq$-1}<br>$$<br>我们必然有：<br>$$<br>\text{mainString[i-k]$\backsim$[i-1] == modeString[0]$\backsim$[k-1]}<br>$$<br>由此我们就不需要匹配0~k-1了，只需判断<br>$$<br>\text{? mainString[mainIndex] == modeString[k]}<br>$$<br>基于证明步骤的（1）、（2）</p>
<p>对模式串，其长度为modeStrLen，与主串，其长度为mainStrLen</p>
<p>如果主串上有子串与模式串匹配，那么我们就可以将模式串从头遍历完毕，即使modeIndex == modeStrLen</p>
<p>如果主串上没有有子串与模式串匹配，那么我们就可以将主串串从头遍历完毕且我们没有遍历完毕模式串，即使modeIndex != modeStrLen</p>
<p>将上述推导转换为代码即可</p>
<p>得证！</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上是一些不严谨的证明，是否严谨不重要，重要的是在推理证明的过程中理解了KMP算法，思路最重要。就我个人而言，网上也有很多帖子给了我很多新的认知，但是看一次记住了，用一次就忘一次。无论是图例还是结合例子解释都让我感觉只是当时理解了KMP，但是其实并没有完全理解KMP为什么要这么做，这么做为什么可以保证算法的正确性。这一次花了一些时间，自己进行了一下推导证明突然就感觉通透了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/" class="post-title-link" itemprop="url">机器学习笔记三：SVM支持向量机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-08 21:52:50" itemprop="dateCreated datePublished" datetime="2021-07-08T21:52:50+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h2><p>线性可分：<br>$$<br>\text{点集}D_0,D_1,\text{对任意一点$x$有}:\<br>\begin{aligned}<br>&amp;\omega^Tx+b\lt0,\quad x\in D_0\<br>&amp;\omega^Tx+b\gt0,\quad x\in D_1\<br>\end{aligned}<br>$$<br>称两个集合线性可分</p>
<p>最大间隔超平面：</p>
<p>能将两个线性可分的集合正确划分开的平面就是超平面：$\omega^Tx+b=0$</p>
<p>为了使这个超平面更具鲁棒性，我们会去找最佳超平面，以最大间隔把两类样本分开的超平面，也称之为最大间隔超平面。</p>
<ul>
<li>两类样本分别分割在该超平面的两侧；</li>
<li>两侧距离超平面最近的样本点到超平面的距离被最大化了。</li>
</ul>
<p>支持向量（Support Vector）：</p>
<p>样本中距离超平面最近的一些点，这些点叫做支持向量。</p>
<h2 id="SVM最优化问题"><a href="#SVM最优化问题" class="headerlink" title="SVM最优化问题"></a>SVM最优化问题</h2><p>找到一个最优超平面划分两类样本$y\in{1,-1}$。</p>
<p>对任意超平面：<br>$$<br>\omega^Tx+b=0<br>$$<br>任一点$x$到其上的距离为：<br>$$<br>l=\frac{|\omega^Tx+b|}{||\omega||}<br>$$<br>设支持向量到超平面的距离为$d$（为了便于区分），对样本集${x,y}$有：<br>$$<br>\begin{cases}<br>\frac{\omega^Tx+b}{||\omega||}\ge d,\quad y=1\<br>\frac{\omega^Tx+b}{||\omega||}\le  -d,\quad y=-1\<br>\end{cases}<br>$$<br>也就是<br>$$<br>\Leftrightarrow\quad\frac{y(\omega^Tx+b)}{||\omega||}\ge d\<br>\Leftrightarrow\quad\frac{y(\omega^Tx+b)}{d||\omega||}\ge 1\<br>$$<br>对支持向量${x’,y’}$有：<br>$$<br>\frac{y’(\omega^Tx’+b)}{||\omega||}=d<br>$$<br>我们的目标是在样本集中，选取最大的$d$，即<br>$$<br>\max{d}<br>$$<br>在此我们做一些处理：<br>$$<br>\text{令$\omega’=\frac{\omega}{d||\omega||},b’=\frac{b}{d||\omega||}$}\<br>$$<br>探究一下距离会如何变换：<br>$$<br>||\omega’||=\frac{||\omega||}{d||\omega||}=1/d\<br>d’=\frac{y’(\omega’^Tx’+b’)}{||\omega’||}=\frac{y’(\omega^Tx’+b)}{||\omega||}=d\<br>$$<br>发现并不影响距离。</p>
<p>那么我们可令：<br>$$<br>d=\frac{1}{||\omega’||}<br>$$<br>由此我们可以重写以上的优化问题：<br>$$<br>\begin{cases}<br>\max{\frac{1}{||\omega||}}\<br>s.t\quad y(\omega^Tx+b)\ge 1\<br>\end{cases}<br>$$<br>其等价于<br>$$<br>\begin{cases}<br>\min{\frac{1}{2}||\omega||^2}\<br>s.t.\quad y(\omega^Tx+b)\ge 1\<br>\end{cases}<br>$$<br>这就是最后我们要优化的约束问题。</p>
<h2 id="拉格朗日数乘法"><a href="#拉格朗日数乘法" class="headerlink" title="拉格朗日数乘法"></a>拉格朗日数乘法</h2><h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>只看不等式的约束条件（无推导直接用）：</p>
<p>要优化：<br>$$<br>\begin{cases}<br>\min{f(x)}\<br>s.t.\quad g_j(x)\le0,\quad j=1,2,\cdots,p(\text{不等式约束条件的个数})\<br>h_k(x)=0,\quad k=1,2,\cdots,q(\text{等式约束条件的个数})\<br>\end{cases}<br>$$<br>KKT条件给出了判断$\pmb{x^*}$是否为最优解的必要条件，即：<br>$$<br>L(x,\lambda,\mu)=f(x)+\sum_{j=1}^q{\mu_jg_j(x)}+\sum^p_{k=1}{\lambda_kh_k(x)}<br>$$<br>若要求解上述优化问题，必须满足条件：<br>$$<br>\begin{cases}<br>\frac{\partial L}{\partial\omega}|_{x=x^*}=0&amp;\qquad(1)\<br>\lambda_j\neq0&amp;\qquad(2)\<br>u_k\ge0&amp;\qquad(3)\<br>u_kg_k(x^*)=0&amp;\qquad(4)\<br>h_j(x^*)=0&amp;\qquad(5)\<br>g_k(x^*)\le0&amp;\qquad(6)\<br>\end{cases}<br>$$<br>其实都能解释的，只挑第四个必要条件解释，分两种情况：1：解在不等式约束条件外部，则可无视该不等式约束条件；2：解在不等式边界条件的边界上，此时不等式为0。</p>
<h3 id="对偶化"><a href="#对偶化" class="headerlink" title="对偶化"></a>对偶化</h3><p>$$<br>\begin{cases}<br>\min{\frac{1}{2}||\omega||^2}\<br>s.t.\quad 1-y(\omega^Tx+b)\le 0\<br>\end{cases}<br>$$</p>
<p>假定有m个样本。</p>
<p>其拉格朗日数乘函数：<br>$$<br>L(w,\mu)=\frac{1}{2}||\omega||^2+\sum^m_{k=1}\mu_k\left[1-y_k(\omega^Tx_k+b)\right]<br>$$<br>要得：<br>$$<br>\min_{\omega,b}{L}<br>$$<br>可以先去<strong>go to</strong></p>
<h4 id="插入一个小插曲，其实很重要，但是可能会产生困扰，先在这打个标记"><a href="#插入一个小插曲，其实很重要，但是可能会产生困扰，先在这打个标记" class="headerlink" title="插入一个小插曲，其实很重要，但是可能会产生困扰，先在这打个标记"></a>插入一个小插曲，其实很重要，但是可能会产生困扰，先在这打个标记</h4><p>在这之前，插入一个对偶化，这一步可以暂时不看，推出超平面后可以回来看看。</p>
<p>我们记一个函数：<br>$$<br>\Theta(\omega)=\max_{\mu}{L}<br>$$<br>对任意点（不止是样本点）满足：<br>$$<br>\begin{cases}<br>\mu_k=\infty,\quad&amp;1-y(\omega^Tx+b)&gt;0\<br>\mu_k\text{不变},\quad&amp;1-y(\omega^Tx+b)\le0<br>\end{cases}<br>$$<br>则<br>$$<br>\Theta(\omega)=\max_{\mu}{L}=<br>\begin{cases}<br>\infty,\quad&amp;1-y(\omega^Tx+b)&gt;0\<br>\frac{1}{2}||\omega||^2,\quad&amp;1-y(\omega^Tx+b)\le0\<br>\end{cases}<br>$$<br>那么：<br>$$<br>\min_{\omega}(\max_{\mu}{L})=\frac{1}{2}||\omega||^2<br>$$<br>与我们的优化目标相同。</p>
<p>一般而言，有：<br>$$<br>\min(\max)\ge\max(\min)<br>$$<br>如果问题是凸优化问题，则有强对偶关系：<br>$$<br>\min(\max)=\max(\min)<br>$$<br>由此我们的优化问题可为：<br>$$<br>\max_{\mu}(\min_{\omega,b}{L})<br>$$</p>
<h4 id="go-to"><a href="#go-to" class="headerlink" title="go to"></a>go to</h4><p>由KKT条件：<br>$$<br>\begin{cases}<br>\frac{\partial L}{\partial\omega}=0\<br>\frac{\partial L}{\partial b}=0\<br>\end{cases}<br>$$<br>又有：<br>$$<br>\begin{aligned}<br>\frac{\partial L}{\partial\omega}&amp;=\omega-\sum^m_{k=1}\mu_ky_kx_k\<br>\frac{\partial L}{\partial b}&amp;=-\sum^m_{k=1}\mu_ky_k\<br>\end{aligned}<br>$$<br>解得：<br>$$<br>\omega=\sum^m_{k=1}\mu_ky_kx_k\<br>\sum^m_{k=1}\mu_ky_k=0\<br>$$<br>注意$\omega\in R^n$以及$x_i\in R^n$</p>
<p>有：<br>$$<br>\begin{aligned}<br>L&amp;=\frac{1}{2}\omega^T\omega+\sum^m_{i=1}\mu_i\left[1-y_i(\omega^Tx_i+b)\right]\<br>&amp;=\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\mu_i\mu_jx_j^Tx_iy_iy_j+\sum^m_{i=1}\mu_i\left[1-y_i(\sum^m_{j=1}\mu_jy_jx_j^Tx_i+b)\right]\<br>&amp;=\sum^m_{i=1}\mu_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\mu_i\mu_jx_j^Tx_iy_iy_j<br>\end{aligned}<br>$$<br>还有未知系数$\mu_i$，此时可以回看小插曲。</p>
<p>有：<br>$$<br>\max_{\mu}\left(\sum^m_{i=1}\mu_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\mu_i\mu_jx_j^Tx_iy_iy_j\right)\<br>s.t.\quad\sum^m_{i=1}\mu_iy_i=0\<br>\mu_i\ge0\<br>$$<br>好了只要解决最后这个问题就可以了。</p>
<h2 id="SMO-Sequential-Minimal-Optimization-算法求解"><a href="#SMO-Sequential-Minimal-Optimization-算法求解" class="headerlink" title="SMO(Sequential Minimal Optimization) 算法求解"></a>SMO(Sequential Minimal Optimization) 算法求解</h2><ol>
<li><p>选择需要更新的两个参数<br>$$<br>\mu_i,\mu_j<br>$$</p>
</li>
<li><p>固定其他参数，由等式约束条件解得<br>$$<br>\mu_iy_i+\mu_jy_j=c=-\sum^m_{k=1}\mu_ky_k=0(k\neq i,j)\<br>\mu_j=\frac{c-\mu_iy_i}{y_j}<br>$$</p>
</li>
<li><p>对于仅有一个约束条件的最优化问题</p>
<p>只要让对于其的导数为0即可，求出$\mu_i$</p>
</li>
<li><p>多次迭代直至收敛。</p>
</li>
</ol>
<p>最后可得：<br>$$<br>\omega=\sum^m_{k=1}\mu_ky_kx_k\<br>$$<br>对任意一个支持向量$x_s$，都满足：<br>$$<br>y_s(\omega^Tx_S+b)=1\<br>b=y_s-\omega^Tx_s<br>$$<br>当然，取均值最好。</p>
<h2 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h2><p>已经获得超平面，将其带入决策函数即可得样本的分类。</p>
<h2 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h2><p>实际中，完全线性可分的样本是很少的。那么我们可以允许一些样本落在隔离带内，即允许有部分样本：<br>$$<br>1-y(\omega^Tx+b)&gt;0<br>$$<br>为了度量我们的松弛程度引入松弛变量<br>$$<br>\xi_i\ge0<br>$$<br>对每个样本：<br>$$<br>1-y_i(\omega^Tx_i+b)-\xi_i\le0<br>$$<br>由此，优化目标为：<br>$$<br>\begin{cases}<br>\min{\frac{1}{2}||\omega||^2}+C\sum^m_{i=1}\xi_i\<br>s.t.\quad 1-y_i(\omega^Tx_i+b)-\xi_i\le0\<br>\xi_i\ge0<br>\end{cases}<br>$$<br>C为惩罚因子，越大对离群的样本惩罚就更大，也就是越不关注异常样本。</p>
<h3 id="构造拉格朗日函数"><a href="#构造拉格朗日函数" class="headerlink" title="构造拉格朗日函数"></a>构造拉格朗日函数</h3><p>由之前的强对偶化，可有：<br>$$<br>\begin{aligned}<br>\max_{\mu,\lambda}\left(\min_{\omega,b,\xi}\left{\frac{1}{2}||\omega||^2+C\sum^m_{i=1}\xi_i+\sum^m_{i=1}\mu_i\left[1-y_i(\omega^Tx_i+b)-\xi_i\right])-\sum^m_{i=1}\lambda_i\xi_i\right}\right)<br>\end{aligned}<br>$$</p>
<h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><p>有：<br>$$<br>\omega=\sum^m_{k=1}\mu_ky_kx_k\<br>\sum^m_{k=1}\mu_ky_k=0\<br>C=\mu_i+\lambda_i<br>$$</p>
<h3 id="带回原函数"><a href="#带回原函数" class="headerlink" title="带回原函数"></a>带回原函数</h3><p>有：<br>$$<br>\begin{aligned}<br>L&amp;=\sum^m_{i=1}\mu_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\mu_i\mu_jx_j^Tx_iy_iy_j+\sum^m_{i=1}(\mu_i+\lambda_i)\xi_i-\sum^m_{i=1}(\mu_i\xi_i+\lambda_i\xi_i)\<br>&amp;=\sum^m_{i=1}\mu_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\mu_i\mu_jx_j^Tx_iy_iy_j<br>\end{aligned}<br>$$<br>则无需最大化$\lambda$：<br>$$<br>\max_{\mu}\left(\sum^m_{i=1}\mu_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\mu_i\mu_jx_j^Tx_iy_iy_j\right)\<br>s.t.\quad\sum^m_{i=1}\mu_iy_i=0\<br>\mu_i\ge0\<br>C-\mu_i-\lambda_i=0\<br>$$<br>最后SMO优化即可</p>
<p><strong>这边要注意一个问题，在间隔内的那部分样本点是不是支持向量？</strong></p>
<p>我们可以由求参数$\omega=\sum^m_{i=1}\mu_iy_ix_i$ 的那个式子可看出，只要$\mu_i&gt;0$ 的点都能够影响我们的超平面，因此都是支持向量。（？？）</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>我们刚刚讨论的硬间隔和软间隔都是在说样本的完全线性可分或者大部分样本点的线性可分。但我们可能会碰到的一种情况是样本点不是线性可分的。</p>
<p>把样本映射到高维空间去：<br>$$<br>x’=\phi(x),y’=y<br>$$</p>
<h3 id="常见核函数"><a href="#常见核函数" class="headerlink" title="常见核函数"></a>常见核函数</h3><ol>
<li><strong>线性核函数</strong></li>
<li><strong>多项式核函数</strong></li>
<li><strong>高斯核函数</strong></li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h3><ul>
<li>有严格的数学理论支持，可解释性强，不依靠统计方法，从而简化了通常的分类和回归问题；</li>
<li>能找出对任务至关重要的关键样本（即：支持向量）；</li>
<li>采用核技巧之后，可以处理非线性分类/回归任务；</li>
<li>最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。</li>
</ul>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h3><ul>
<li>训练时间长。当采用 SMO 算法时，由于每次都需要挑选一对参数，因此时间复杂度为$O(N^2)$ ，其中 N 为训练样本的数量；</li>
<li>当采用核技巧时，如果需要存储核矩阵，则空间复杂度为$O(N^2)$ ；</li>
<li>模型预测时，预测时间与支持向量的个数成正比。当支持向量的数量较大时，预测计算复杂度较高。</li>
</ul>
<p>因此支持向量机目前只适合小批量样本的任务，无法适应百万甚至上亿样本的任务。</p>
<hr>
<p>参考：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77750026">https://zhuanlan.zhihu.com/p/77750026</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/" class="post-title-link" itemprop="url">机器学习笔记二：神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-05 13:41:00" itemprop="dateCreated datePublished" datetime="2021-07-05T13:41:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记：<br>$$<br>\text{对输入层，层数为1}:\<br>x^{k}_i:\text{第k个数据的第i个输入},i\in[1,m]<br>$$</p>
<p>$$<br>\text{对隐藏层}:\<br>l:\text{当前层数}\in[2,L-1],s_l:\text{当前层数的单元数}，\w^{(l)}_{ij}:\text{连接第l+1层的第i个输入和第l层的第j个输出的权重}<br>$$</p>
<p>$$<br>z^{(l+1)}<em>{i}=\sum^{s_l}</em>{j=1}{w^{(l)}<em>{ij}a^{(l)}</em>{j}}+b^{(l)}<em>i:\text{第l+1层的第i输入},\a^{(l)}</em>{i}=f(z^{(l)}_{i}):\text{第l层的第i个输出},b^{(l)}_i:\text{第l层到第l+l层的第i个单元的偏置，为常数}<br>$$</p>
<p>$$<br>Z^{(l+1)}={W^{(l)}}\pmb{a^{l}}+\pmb{b^{l}}<br>$$</p>
<p>$$<br>f(z)=\frac{1}{1+e^{-z}},f’(z)=(1-f(z))f(z)<br>$$</p>
<p>$$<br>\text{对输出层，层数为L}:<br>a^{(L)}_i:\text{第i个输入数据的输出},y_k:\text{第k个数据的实际值},i\in[1,m]<br>$$</p>
<h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>$$<br>\pmb{X}=\pmb{a^{(1)}}\to\pmb{z^{(2)}}\to\pmb{a^{(2)}}\to\cdots\to\pmb{a^{(L)}}<br>$$</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>$$<br>J=\frac{1}{2m}\sum_{i=1}^m\left(a^{(L)}<em>i-y_i\right)^2\<br>\text{正则化}:J=\frac{1}{2m}\sum</em>{i=1}^m\left(a^{(L)}<em>i-y_i\right)^2+\frac{\lambda}{2m}\sum^{L-1}</em>{l=1}\pmb{w^{(l)}}^T\pmb{w^{(l)}}=\frac{1}{2m}\sum_{i=1}^m\left(a^{(L)}<em>i-y_i\right)^2+\frac{\lambda}{2m}\sum^{L-1}</em>{l=1}\sum_{i=1}^{s_l}\sum_{j=1}^{s_{l+1}}(w^{(l)}_{ji})2<br>$$</p>
<p>在逻辑分类中：<br>$$<br>J=-\frac{1}{m}\sum^m_{i=1}\left(y^{i}\log(a^{(L)}<em>i)+(1-y^{i})\log(1-a^{L}<em>i)\right)\<br>\text{正则化}:J=-\frac{1}{m}\sum^m</em>{i=1}\left(y^{i}\log(a^{(L)}<em>i)+(1-y^{i})\log(1-a^{L}<em>i)\right)+\frac{\lambda}{2m}\sum^{L-1}</em>{l=1}\sum</em>{i=1}^{s_l}\sum</em>{j=1}^{s_{l+1}}(w^{(l)}_{ji})2<br>$$</p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>由代价函数更新权重以及偏置矩阵，按梯度下降法有：<br>$$<br>w^{(l)}<em>{ij}=w^{(l)}</em>{ij}-\alpha\frac{\partial J}{\partial w^{(l)}_{ij}}\<br>b^{(l)}_i=b^{(l)}_i-\alpha\frac{\partial J}{\partial b^{(l)}<em>i}<br>$$<br>这里先使用代价函数为：<br>$$<br>J=\frac{1}{2m}\sum</em>{i=1}^m\left(a^{(L)}_i-y_i\right)^2<br>$$</p>
<h3 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h3><p>$$<br>\begin{aligned}<br>\frac{\partial J}{\partial w^{(L-1)}<em>{ij}}&amp;=\frac{1}{2m}\sum</em>{t=1}^m\left(\frac{\partial ((a^{(L)}_t-y_i)^2)}{\partial a^{(L)}<em>t}\frac{\partial a^{(L)}<em>t}{\partial w^{(L)}</em>{ij}}\right)\<br>&amp;=\frac{1}{m}\sum</em>{t=1}^m\left[(a^{(L)}<em>t-y_t)\frac{\partial f(z^{(L)}<em>i)}{\partial w^{(L-1)}</em>{ij}}\right]\<br>&amp;=\frac{1}{m}\sum</em>{t=1}^m\left[(a^{(L)}<em>t-y_t)\frac{\partial f(z^{(L)}<em>i)}{\partial z^{(L)}<em>i}\frac{\partial z^{(L)}<em>i}{\partial w^{(L-1)}</em>{ij}}\right]\<br>&amp;=\frac{1}{m}\sum</em>{t=1}^m\left[(a^{(L)}<em>t-y_t)(1-f(z^{(L)}<em>i))f(z^{(L)}<em>i)\frac{\partial (\sum^{s</em>{L-1}}</em>{k=1}{w^{(L-1)}</em>{ik}a^{(L-1)}</em>{k}}+b^{(L-1)}<em>t)}{\partial w^{(L-1)}</em>{ij}}\right]\<br>&amp;=\frac{1}{m}\sum</em>{t=1}^m\left[(a^{(L)}_t-y_t)(1-f(z^{(L)}_i))f(z^{(L)}_i)a^{(L-1)}<em>j\right]\<br>&amp;=\frac{1}{m}\sum</em>{t=1}^m\left[(a^{(L)}_t-y_t)\frac{\partial f(z^{(L)})}{\partial z^{(L)}_i}a^{(L-1)}_j\right]<br>\end{aligned}<br>$$</p>
<p>注意一下这里最后的代价函数是针对单个数据而言的，然后把他们汇总，再取平均，所以不是除以2m。</p>
<p>这里的t下标代表第几个数据</p>
<p>记：<br>$$<br>\delta^{(L)}_i=\frac{\partial J}{\partial z^{(L)}_i}=(a^{(L)}-y)\frac{\partial f(z^{(L)})}{\partial z^{(L)}_i}<br>$$</p>
<h3 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h3><p>注意一下这里的代价函数是针对单个数据而言的，然后把他们汇总，再取平均，所以不是除以2m。<br>$$<br>\begin{aligned}<br>\frac{\partial J}{\partial w^{(l)}<em>{ij}}&amp;=\frac{1}{m}\sum</em>{t=1}^m\left(\frac{\partial J}{\partial z^{(l+1)}<em>i}\frac{\partial z^{(l+1)}<em>i}{\partial w^{(l)}</em>{ij}}\right)\<br>\delta^{(l+1)}<em>i&amp;=\frac{\partial J}{\partial z^{(l+1)}<em>i}\<br>&amp;=\sum^{s</em>{l+2}}</em>{k=1}\left(\frac{\partial J}{\partial z^{(l+2)}<em>k}\frac{\partial z^{(l+2)}<em>k}{\partial z^{(l+1)}<em>i}\right)\<br>&amp;=\sum^{s</em>{l+2}}</em>{k=1}\left[\delta^{(l+2)}<em>k\frac{\partial (\sum^{s</em>{l+1}}</em>{j=1}{w^{(l+1)}</em>{kj}a^{(l+1)}<em>{j}}+b^{(l+1)}<em>k)}{\partial z^{(l+1)}<em>i}\right]\<br>&amp;=\sum^{s</em>{l+2}}</em>{k=1}\left[\delta^{(l+2)}<em>k\frac{\partial (\sum^{s</em>{l+1}}</em>{j=1}{w^{(l+1)}<em>{kj}f(z^{(l+1)}</em>{j}})+b^{(l+1)}<em>k)}{\partial z^{(l+1)}<em>i}\right]\<br>&amp;=\sum^{s</em>{l+2}}</em>{k=1}\left[\delta^{(l+2)}<em>kw^{l+1}</em>{ki}f’(z^{(l+1)}<em>i)\right]<br>\end{aligned}\<br>\Rightarrow\<br>\pmb{\delta^{(l+1)}}=\left[{W^{(l)}}^T\pmb{\delta^{(l+1)}}\right]f’(\pmb{z^{(l+1)}})\<br>\frac{\partial J}{\partial w^{(l)}</em>{ij}}=\frac{1}{m}\sum_{t=1}^m\left{a^{(l)}<em>jf’(z^{(l+1)}<em>i)\sum^{s</em>{l+2}}</em>{k=1}\left[\delta^{(l+2)}<em>kw^{l+1}</em>{ki}\right]\right}\<br>\frac{\partial J}{\partial W^{(l)}}=\frac{1}{m}\sum_{t=1}^m\pmb{\delta^{(l+1)}}\pmb{a^{l}}^T<br>$$<br>又已知：<br>$$<br>\pmb{\delta^{(L)}},\pmb{w^{(L-1)}}<br>$$<br>可求解：<br>$$<br>\pmb{\delta^{(L-1)}},\pmb{w^{(L-2)}}<br>$$<br>递归求解，反复迭代</p>
<h3 id="偏置单元"><a href="#偏置单元" class="headerlink" title="偏置单元"></a>偏置单元</h3><p>偏置单元也是如此<br>$$<br>\frac{\partial J}{\partial b^{(L-1)}<em>i}=\frac{1}{m}\sum</em>{t=1}^m\frac{\partial J}{\partial z^{(L)}<em>i}\<br>\frac{\partial J}{\partial \pmb{b^{(L-1)}}}=\pmb{\delta^{(L)}<em>i}\<br>\frac{\partial J}{\partial b^{(l)}<em>i}=\frac{1}{m}\sum</em>{t=1}^m\left{f’(z^{(l+1)}<em>i)\sum^{s</em>{l+2}}</em>{k=1}\left[\delta^{(l+2)}<em>kw^{l+1}</em>{ki}\right]\right}\<br>\frac{\partial J}{\partial \pmb{b^{(L-1)}}}=\frac{1}{m}\sum</em>{t=1}^m\pmb{\delta^{(l+1)}}<br>$$</p>
<h3 id="对逻辑分类"><a href="#对逻辑分类" class="headerlink" title="对逻辑分类"></a>对逻辑分类</h3><p>之前就已经说明过一样的，这里也同理有结论</p>
<h3 id="对正则化"><a href="#对正则化" class="headerlink" title="对正则化"></a>对正则化</h3><p>$$<br>\frac{\partial J}{\partial W^{(l)}}=\frac{1}{m}\sum_{t=1}^m\pmb{\delta^{(l+1)}}\pmb{a^{l}}^T+\frac{\lambda}{m}W^{(l)}<br>$$</p>
<hr>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lliuye/p/9183914.html">https://www.cnblogs.com/lliuye/p/9183914.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32865355/article/details/80260212">https://blog.csdn.net/qq_32865355/article/details/80260212</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/04/ffmpeg%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/04/ffmpeg%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">ffmpeg使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-04 12:42:00" itemprop="dateCreated datePublished" datetime="2021-07-04T12:42:00+08:00">2021-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ffmpeg/" itemprop="url" rel="index"><span itemprop="name">ffmpeg</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用FFmpeg合并MP4视频"><a href="#使用FFmpeg合并MP4视频" class="headerlink" title="使用FFmpeg合并MP4视频"></a>使用FFmpeg合并MP4视频</h2><h3 id="使用FFmpeg拼接"><a href="#使用FFmpeg拼接" class="headerlink" title="使用FFmpeg拼接"></a>使用FFmpeg拼接</h3><p>速度慢，文件大</p>
<p>将 mp4 先转码为 mpeg文件，mpeg是支持简单拼接的，然后再转回 mp4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 1.mp4 -qscale 4 1.mpg</span><br><span class="line">ffmpeg -i 2.mp4 -qscale 4 2.mpg</span><br><span class="line">cat 1.mpg 2.mpg | ffmpeg -f mpeg -i - -qscale 6 -vcodec mpeg4 output.mp4</span><br><span class="line"><span class="comment">#-qscale &lt;数值&gt; 以&lt;数值&gt;质量为基础的VBR，取值0.01-255，约小质量越好</span></span><br></pre></td></tr></table></figure>

<h3 id="使用ts拼接"><a href="#使用ts拼接" class="headerlink" title="使用ts拼接"></a>使用ts拼接</h3><p>速度快，文件小</p>
<p>先将 mp4 转化为同样编码形式的 ts 流，因为 ts流是可以 concate 的，先把 mp4 封装成 ts ，然后 concate ts 流， 最后再把 ts 流转化为 mp4。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts</span><br><span class="line">ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts</span><br><span class="line">ffmpeg -i <span class="string">&quot;concat:1.ts|2.ts&quot;</span> -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4</span><br></pre></td></tr></table></figure>

<p>————————————————<br>版权声明：本文为CSDN博主「熊观鱼」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/east196/article/details/79821361">https://blog.csdn.net/east196/article/details/79821361</a></p>
<h3 id="使用mpeg拼接（另一种方法）"><a href="#使用mpeg拼接（另一种方法）" class="headerlink" title="使用mpeg拼接（另一种方法）"></a>使用mpeg拼接（另一种方法）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 1.mp4 –f mpeg 1.mpg</span><br><span class="line">ffmpeg -i 2.mp4 –f mpeg 2.mpg</span><br></pre></td></tr></table></figure>

<p>win10，打开cmd（copy命令在powershell和gitbash里都不好使）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy &#x2F;b 1.mpg + 2.mpg 3.mpg</span><br><span class="line">ffmpeg -i 3.mpg -f mp4 3.mp4</span><br></pre></td></tr></table></figure>

<h3 id="FFmpeg合并MP4视频总结"><a href="#FFmpeg合并MP4视频总结" class="headerlink" title="FFmpeg合并MP4视频总结"></a>FFmpeg合并MP4视频总结</h3><p>ts是真的又快又好</p>
<h2 id="FFmpeg批量处理mp4-win"><a href="#FFmpeg批量处理mp4-win" class="headerlink" title="FFmpeg批量处理mp4 win"></a>FFmpeg批量处理mp4 win</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> n=0</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (*.mp4) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">set</span> /a n+=1</span><br><span class="line">    <span class="built_in">echo</span> %%i</span><br><span class="line">    <span class="built_in">echo</span> !n!</span><br><span class="line">    ffmpeg -i <span class="string">&quot;%%i&quot;</span> -c copy <span class="string">&quot;%%~ni.ts&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> !n! geq 10 (</span><br><span class="line">    <span class="built_in">set</span> /a n=0</span><br><span class="line">    <span class="keyword">for</span> %%i <span class="keyword">in</span> (*.ts) <span class="keyword">do</span> (</span><br><span class="line">        <span class="built_in">echo</span> %%i</span><br><span class="line">        <span class="built_in">set</span> /a n+=1</span><br><span class="line">        <span class="keyword">if</span> !n! geq 10 (</span><br><span class="line">            rename  <span class="string">&quot;%%i&quot;</span>  <span class="string">&quot;file !n!.ts&quot;</span></span><br><span class="line">        ) <span class="keyword">else</span> (</span><br><span class="line">        	rename  <span class="string">&quot;%%i&quot;</span>  <span class="string">&quot;file 0!n!.ts&quot;</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">set</span> /a n=0</span><br><span class="line">    <span class="keyword">for</span> %%i <span class="keyword">in</span> (*.ts) <span class="keyword">do</span> (</span><br><span class="line">        <span class="built_in">set</span> /a n+=1</span><br><span class="line">        rename  <span class="string">&quot;%%i&quot;</span>  <span class="string">&quot;file !n!.ts&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">dir *.ts /B &gt;filelist.txt</span><br><span class="line"><span class="keyword">if</span> !n! geq 10 (</span><br><span class="line">    <span class="built_in">set</span> /a n=0</span><br><span class="line">    <span class="keyword">for</span> %%i <span class="keyword">in</span> (*.ts) <span class="keyword">do</span> (</span><br><span class="line">        <span class="built_in">echo</span> %%i</span><br><span class="line">        <span class="built_in">set</span> /a n+=1</span><br><span class="line">        <span class="keyword">if</span> !n! geq 10 (</span><br><span class="line">            rename  <span class="string">&quot;%%i&quot;</span>  <span class="string">&quot;!n!.ts&quot;</span></span><br><span class="line">        ) <span class="keyword">else</span> (</span><br><span class="line">        	rename  <span class="string">&quot;%%i&quot;</span>  <span class="string">&quot;0!n!.ts&quot;</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">set</span> /a n=0</span><br><span class="line">    <span class="keyword">for</span> %%i <span class="keyword">in</span> (*.ts) <span class="keyword">do</span> (</span><br><span class="line">        <span class="built_in">set</span> /a n+=1</span><br><span class="line">        rename  <span class="string">&quot;%%i&quot;</span>  <span class="string">&quot;!n!.ts&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">ffmpeg -f concat -i filelist.txt -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4</span><br><span class="line">del *.ts</span><br></pre></td></tr></table></figure>

<h2 id="FFmpeg提取字幕流"><a href="#FFmpeg提取字幕流" class="headerlink" title="FFmpeg提取字幕流"></a>FFmpeg提取字幕流</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mkv -an -vn -scodec copy sub.ass</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/" class="post-title-link" itemprop="url">机器学习笔记一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-17 09:06:17" itemprop="dateCreated datePublished" datetime="2021-06-17T09:06:17+08:00">2021-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>写在前边，大纲基于吴恩达机器学习系列课程，以机器学习西瓜书作为补充。<br>大部分靠随堂记的笔记写成，所以可能概念上很不清楚<br>MH 2021.06.12</p>
</blockquote>
<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>NULL</p>
<h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><h3 id="LinearRegression线性回归"><a href="#LinearRegression线性回归" class="headerlink" title="LinearRegression线性回归"></a>LinearRegression线性回归</h3><p>基于输入数据，由假设函数去预测值。<br>记输入数据为<br>$$<br>\pmb{X}=\left[<br>    \begin{matrix}<br>    x_{11}&amp;x_{12}&amp;\cdots&amp;x_{1n}\<br>    x_{21}&amp;x_{22}&amp;\cdots&amp;x_{2n}\<br>    \vdots&amp;\vdots&amp;\ddots&amp;\vdots\<br>    x_{m1}&amp;x_{m2}&amp;\cdots&amp;x_{mn}<br>    \end{matrix}<br>\right]^T\<br>{\text{有m个数据的输入，每个数据有n个特征项}}\<br>\pmb{x_i}=[x_{i1},x_{i2},\cdots,x_{in}]^T\text{代表第i个输入数据，}x_{ij}\text{代表第i个输入数据的第j个特征}\<br>\pmb{Y}=\left[<br>    \begin{matrix}<br>    Y_1&amp;\cdots&amp;Y_m<br>    \end{matrix}<br>\right]^T\<br>\text{m个数据对应实际的输出值}<br>$$<br>假设函数是输入项的线性组合，即：<br>$$<br>h_{\theta}(\pmb{x})=\pmb{\theta}^T\pmb{x}+b\<br>h_{\theta}\text{为假设函数，}<br>\pmb{\theta}=\left[<br>    \begin{matrix}<br>    \theta_1&amp;\cdots&amp;\theta_j<br>    \end{matrix}<br>\right]^T\text{为系数向量}\<br>h_{\theta}(\pmb{x})\text{的值表示}\pmb{x}\text{输入时函数的预测值}\<br>b\text{为常数}\<br>\text{我们也可以把常数归入系数中去，实际上吴恩达的课程就是这么做的}\<br>\Rightarrow<br>\pmb{X}=\left[<br>    \begin{matrix}<br>    x_{10}&amp;x_{11}&amp;\cdots&amp;x_{1n}\<br>    x_{20}&amp;x_{21}&amp;\cdots&amp;x_{2n}\<br>    \vdots&amp;\vdots&amp;\ddots&amp;\vdots\<br>    x_{m0}&amp;x_{m1}&amp;\cdots&amp;x_{mn}<br>    \end{matrix}<br>\right]^T\quad<br>\pmb{\theta}=\left[<br>    \begin{matrix}<br>    \theta_0&amp;\theta_1&amp;\cdots&amp;\theta_n<br>    \end{matrix}<br>\right]^T\<br>x_{10}=x_{20}=\cdots=x_{m0}=1\<br>[h_{\theta}(\pmb{x})]=\pmb{\theta}^T\pmb{X}<br>$$<br>现在的问题是如何求出系数向量，使得假设函数能很好的去预测，一个很直观的想法就是如果假设函数能很好的去预测，那么同样的假设函数对训练集（train set）也应该取得很好的效果（未考虑 <em><em>过拟合__），而正好在高中阶段我们就已经接触过这一方面的概念，即最小二乘法的线性规划。<br>$$<br>y=\hat{a}x+\hat{b}\<br>\hat{a}=\frac{\sum</em>{i=1}^m{y_i(x_i-\bar{x})}}{\sum</em>{i=1}^m{x_i^2}-\frac{(\sum_{i=1}^m{x_i})^2}{m}},\hat{b}=\frac{\sum_{i=1}^m{y_i-\bar{a}x_i}}{m}<br>$$<br>其中的原理是定义了一个距离函数，最小二乘法能让该距离函数的取值最小。我们也定义一代价函数（cost function）<br>$$<br>J(\theta_0,\theta_1,\cdots,\theta_n)=\frac{1}{2m}\sum_{i=1}^m{(h_{\theta}(\pmb{x_i})-y_i)^2}=\frac{1}{2m}(\pmb{\theta}^T\pmb{X}-\pmb{Y})^T(\pmb{\theta}^T\pmb{X}-\pmb{Y})=\frac{1}{2m}(\pmb{X}^T\pmb{\theta}-\pmb{Y})^T(\pmb{X}^T\pmb{\theta}-\pmb{Y})\<br>\pmb{\theta}\text{使得代价函数最小时取得的值}\quad\pmb{\theta}=\min_{\pmb{\theta}}(J(\theta_0,\theta_1,\cdots,\theta_n))<br>$$</p>
<h4 id="正定方程求解"><a href="#正定方程求解" class="headerlink" title="正定方程求解"></a>正定方程求解</h4><p>$$<br>\frac{\partial J}{\partial\pmb{\theta}}=\pmb{X}^T(\pmb{X}\pmb{\theta}-\pmb{Y})/m\<br>\text{取极值时，导数为0，如果对于凸函数，为极小值点，此时有}\<br>\pmb{\theta}=(\pmb{X}^T\pmb{X})^{-1}\pmb{X}^TY\<br>\text{要求}X^TX\text{为满秩矩阵，但是也可以不满秩，在Otcave中可以使用pinv求}<br>$$</p>
<h4 id="梯度下降法求解"><a href="#梯度下降法求解" class="headerlink" title="梯度下降法求解"></a>梯度下降法求解</h4><p>梯度是函数变化最快的点，负梯度是下降最快的方向，对于一个凸函数，我们沿着其负梯度一路走下，肯定能到达一个局部最优点，对于只有一个谷底的凸函数，我们一定能到达最优点。<br>由此得到一个迭代式<br>$$<br>\theta_j=\theta_j-\alpha\frac{\partial J}{\partial\theta_j}=\theta_j-\frac{\alpha}{m}\sum_{i=1}^m{(h_{\theta}(\pmb{x_i})-y_i)x_{ij}}\<br>\text{$\alpha$为学习率，只要学习率足够小，$J$每次迭代都会变小。选择合适的学习率很重要，太大反复，太小太慢}<br>$$</p>
<p>迭代退出条件可设置为结果小于某一值或者自己设置步数，注意的是不能随时更新系数的值，要等待所有新系数的都被计算出来后才能更新</p>
<h4 id="FeaturingScalling特征缩放"><a href="#FeaturingScalling特征缩放" class="headerlink" title="FeaturingScalling特征缩放"></a>FeaturingScalling特征缩放</h4><p>使得开始时特征的数量级在差不多相近的水平上，加快收敛</p>
<ol>
<li>最大最小归一化：$x_i=\frac{x_i-min}{max-min}$</li>
<li>均值归一化：$x_i=\frac{x_i-\mu}{max-min}$</li>
<li>标准化：$x_i=\frac{x_i-\mu}{\sigma}$</li>
</ol>
<h3 id="LogisticRegressionClassification逻辑回归分类问题"><a href="#LogisticRegressionClassification逻辑回归分类问题" class="headerlink" title="LogisticRegressionClassification逻辑回归分类问题"></a>LogisticRegressionClassification逻辑回归分类问题</h3><p>考虑一个分类问题，我们并不关心预测的值是什么，而只关心它是不是。如对于一个二分类问题，其输出只有是与不是。在这类问题中：<br>$$<br>\pmb{X}=\left[<br>    \begin{matrix}<br>    x_{10}&amp;x_{11}&amp;\cdots&amp;x_{1n}\<br>    x_{20}&amp;x_{21}&amp;\cdots&amp;x_{2n}\<br>    \vdots&amp;\vdots&amp;\ddots&amp;\vdots\<br>    x_{m0}&amp;x_{m1}&amp;\cdots&amp;x_{mn}<br>    \end{matrix}<br>\right]^T\<br>{\text{有m个数据的输入，每个数据有n个特征项，0标的为1}}\<br>\pmb{x_i}=[x_{i1},x_{i2},\cdots,x_{in}]^T\text{代表第i个输入数据，}x_{ij}\text{代表第i个输入数据的第j个特征}\<br>\pmb{Y}=\left[<br>    \begin{matrix}<br>    y_1&amp;\cdots&amp;y_m<br>    \end{matrix}<br>\right]^T\<br>\text{m个数据对应实际的输出值，且}y\in{0,1}<br>$$<br>如何开发一个算法使得其能正确的分类呢。考虑上面的线性回归，我们可以把预测值与是与否联系起来，如是设置一个一个边界，在靠边界区分。西瓜书使用了“广义线性模型”，寻找一个单调可微函数将分类任务的真实标记与预测值联系起来。（为什么一定要单调可微）<br>$$<br>\text{对二分类问题，记z为预测值，y为标记值，采用阶跃函数}\<br>y=\begin{cases}<br>0&amp;z&lt;0\<br>0.5&amp;z=0、text{临界值任意判别}\<br>1&amp;z&gt;0<br>\end{cases}<br>$$<br>但阶跃函数在0点不可微，所以要找一个代替函数<br>$$<br>g(x)=\frac{1}{1+e^{-x}}\quad g(x)\in[0,1]<br>$$<br>Sigmoid函数<br>$$<br>h_{\theta}(\pmb{x})=g(\pmb{\theta}^T\pmb{x})=\frac{1}{1+e^{-\theta^T\pmb{x}}}\<br>P(y=1|\pmb{x};\pmb{\theta})=h_{\pmb{\theta}}(\pmb{x})\<br>P(y=0|\pmb{x};\pmb{\theta})=1-h_{\pmb{\theta}}(\pmb{x})\<br>\text{由}y=\frac{1}{1+e^{-x}}\rightarrow x=\ln{\frac{y}{1-y}}\<br>\Rightarrow\theta^T\pmb{x}=\ln{\frac{P(y=1|\pmb{x};\pmb{\theta})}{P(y=0|\pmb{x};\pmb{\theta})}}<br>$$</p>
<p>那么代价函数就不能使用LinearRegression一样的代价函数了，如果这么去使用会得到一个波浪型的函数图像，为非凸函数，存在多个局部最小值。<br>考虑到这是个概率问题，且要确定的是参数，在《概率论与数理统计》第7章参数估计中有依样本均值估计总体的方法。</p>
<h4 id="最大似然估计法"><a href="#最大似然估计法" class="headerlink" title="最大似然估计法"></a>最大似然估计法</h4><p>若总体$X$的分布形式$p(x;\theta)$已知，其中$\theta\in\Theta$为未知参数，$\Theta$是$\theta$可能的取值范围。$X_1,\cdots,X_m$来自是来自总体的样本，其值为$x_1,\cdots,x_m$，称$L(\theta)=\Pi_{i=1}^mp(x_i;\theta)$为参数$\theta$的似然函数。<br>很容易看出似然函数其实就是$X_1,\cdots,X_m$一起发生的可能性，即联合概率。很直观的，如果我们观察到了这些样本值，就很有把握去说能使得似然函数取最大值的，参数$\theta$是最好去符合总体的参数。<br>对应LogisticRegression问题，训练集对应的值为$\pmb{Y}$。问题转为<br>$$<br>L(\pmb{x_1},\pmb{x_2},\cdots,\pmb{x_m};\pmb{\theta})=\max_{\pmb{\theta}\in\pmb{\theta}}{\Pi_{i=1}^mp(\pmb{x_i};\pmb{\theta})}\<br>p(\pmb{x_i};\pmb{\theta})=(1-h_{\theta}(\pmb{x_i}))^{1-y_i}\cdot h_{\theta}(\pmb{x_i})^{y_i},\quad y_i\in{0,1}\<br>\text{很明显$y_i$与$h_{\pmb{\theta}}(\pmb{x_i})$为0-1分布}<br>$$<br>而最大似然函数的求解方法<br>三步走<br>$$<br>\begin{align}<br>L(\pmb{\theta})&amp;=\Pi_{i=1}^mp(\pmb{x_i};\pmb{\theta})\<br>\ln{L(\pmb{\theta})}&amp;=\sum_{i=1}^mp(\pmb{x_i};\pmb{\theta})\<br> &amp;=\sum_{i=1}^m{\ln[1-h_{\theta}(\pmb{x_i})]\cdot{(1-y_i)}+\ln[h_{\theta}(\pmb{x_i})]\cdot{y_i}}\<br>\frac{\partial\ln{L(\pmb{\theta})}}{\partial\theta_j}&amp;=0,\quad j=0,1,2,3,\cdots,n<br>\end{align}<br>$$<br>我们先求导看看<br>$$<br>h_{\theta}(\pmb{x})=g(\pmb{\theta}^T\pmb{x})=\frac{1}{1+e^{-\theta^T\pmb{x}}}\<br>\begin{align}<br>\frac{\partial{\ln[1-h_{\theta}(\pmb{x_i})]\cdot{(1-y_i)}}}{\partial\theta_j}&amp;=\frac{1-y_i}{1-h_{\theta}}\frac{-x_{ij}e^{-\pmb{\theta}^T\pmb{x_i}}}{(1+e^{-\pmb{\theta}^T\pmb{x_i}})^2}\<br>&amp;=\frac{(1-y_i)(1+e^{-\pmb{\theta}^T\pmb{x_i}})}{e^{-\pmb{\theta}^T\pmb{x_i}}}\frac{-x_{ij}e^{-\pmb{\theta}^T\pmb{x_i}}}{(1+e^{-\pmb{\theta}^T\pmb{x_i}})^2}\<br>&amp;=\frac{(y_i-1)x_{ij}}{(1+e^{-\pmb{\theta}^T\pmb{x_i}})}<br>\end{align}\<br>\frac{\partial\ln[h_{\theta}(\pmb{x_i})]\cdot{y_i}}{\partial\theta_j}=\frac{y_ix_{ij}e^{-\pmb{\theta}^T\pmb{x_i}}}{(1+e^{-\pmb{\theta}^T\pmb{x_i}})}\<br>\frac{\partial\ln{L(\pmb{\theta})}}{\partial\theta_j}=-\sum_{i=1}^m{[h_{\theta}(\pmb{x_i})-y_i]x_{ij}}<br>$$<br>定义cost function$=-y\ln{h_{\theta}}-(1-y)\ln(1-h_{\theta})$<br>$J=\frac{1}{m}\sum_{i=1}^{m}cost_i$<br>可用梯度下降法<br>$$<br>Repeat:<br>    \begin{align}<br>    \theta_j&amp;=\theta_j-\alpha\frac{\partial J}{\partial\theta_j}\<br>    \frac{\partial J}{\partial\theta_j}&amp;=\frac{1}{m}\sum_{i=1}^m{[h_{\theta}(\pmb{x_i})-y_i]x_{ij},j=0,1,2,\cdots,n<br>    \end{align}\<br>\text{即有}\pmb{\theta}=\pmb{X}^T[h_\theta-\pmb{Y}]/m<br>$$</p>
<h3 id="Overfitting过度拟合"><a href="#Overfitting过度拟合" class="headerlink" title="Overfitting过度拟合"></a>Overfitting过度拟合</h3><p>无法泛化。<br>解决方法：</p>
<ol>
<li>减少变量个数</li>
<li>正则化，加入惩罚项(缩小某些不重要项的权重？)</li>
</ol>
<p>过度拟合时，加入惩罚项，那么修改代价函数</p>
<h4 id="RegulaziedLinearRegression"><a href="#RegulaziedLinearRegression" class="headerlink" title="RegulaziedLinearRegression"></a>RegulaziedLinearRegression</h4><p>$$<br>J=\frac{1}{2m}\left[\sum_{i=1}^m[h_\theta(\pmb{x_i})-y_i]^2+\lambda\sum_{j=1}^n\theta_j^2\right]\<br>\lambda\text{称为正规化参数}\<br>\text{对梯度下降法}\<br>\theta_0=\theta_0-\frac{\alpha}{m}\sum_{i=1}^m{(h_{\theta}(\pmb{x_i})-y_i)x_{i0}}\<br>\theta_j=\theta_j-\frac{\alpha}{m}\left{\sum_{i=1}^m[h_\theta(\pmb{x_i})-y_i]x_{ij}+\lambda\theta_j\right}=\theta_j(1-\frac{\alpha\lambda}{m})-\frac{\alpha}{m}\sum_{i=1}^m{(h_{\theta}(\pmb{x_i})-y_i)x_{ij}}\<br>j=1,2,\cdots,n\<br>\text{对正则方程}<br>\pmb{\theta}=(\pmb{X}^T\pmb{X}+\lambda\pmb{L})^{-1}X^T\pmb{Y}\quad(\text{求逆的一定是可逆})\<br>\pmb{L}=\left[<br>    \begin{matrix}<br>    0&amp;0&amp;\cdots&amp;0\<br>    0&amp;1&amp;\cdots&amp;0\<br>    \vdots&amp;\vdots&amp;\ddots&amp;\vdots\<br>    0&amp;0&amp;\cdots&amp;1<br>    \end{matrix}<br>\right]<br>$$</p>
<h4 id="RegulaziedLogisticRegression"><a href="#RegulaziedLogisticRegression" class="headerlink" title="RegulaziedLogisticRegression"></a>RegulaziedLogisticRegression</h4><p>$$<br>J=-\frac{1}{m}\sum_{i=1}^{m}[y_i\ln{h_{\theta}(\pmb{x_i})}+(1-y_i)\ln(1-h_{\theta}(\pmb{x_i})]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/08/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/%E5%BE%AE%E6%B3%A2%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">微波技术期末复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-08 21:37:16" itemprop="dateCreated datePublished" datetime="2021-06-08T21:37:16+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8B/" itemprop="url" rel="index"><span itemprop="name">大三下</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ol>
<li>微波的定义、频率、波长范围<br>微波是频率从300MHz到3000GHz范围内的电磁波，$\lambda \in [0.1mm,1m]$</li>
<li>微波的特点<br>似光、似声性，穿透性，非电离性、信息性</li>
<li>导行波的种类与特点<br>种类：TE、TM:能量拘束在金属管内;TEM、准TEM波：能量拘束在导体之间的空间;</li>
</ol>
<h2 id="第二章-传输线理论"><a href="#第二章-传输线理论" class="headerlink" title="第二章 传输线理论"></a>第二章 传输线理论</h2><h3 id="1-传输线方程与其解，重点关注终端解的形式"><a href="#1-传输线方程与其解，重点关注终端解的形式" class="headerlink" title="1.传输线方程与其解，重点关注终端解的形式"></a>1.传输线方程与其解，重点关注终端解的形式</h3><p>对时谐场，由传输线的等效分布参数可得<br>$$<br>v(z,t)=Re{V(z)e^{j\omega t}}\<br>i(z,t)=Re{I(z)e^{j\omega t}}\<br>\frac{dV}{dz}=-(R+j\omega L)I=-ZI\<br>\frac{dI}{dz}=-(Y+j\omega C)V=-YV\<br>\Rightarrow \frac{d^2V}{dz^2}-ZYV=0\<br>\gamma = \sqrt{ZY} \Rightarrow V(z)=A_1e^{-\gamma z}+A_2e^{\gamma z}\<br>Z_0=\sqrt{\frac{Z}{Y}} \Rightarrow I(z)=(A_1e^{-\gamma z}-A_2e^{\gamma z})/Z_0<br>$$<br>得出一般解后，由条件解得系数。</p>
<h4 id="终端解：z-l时，条件已知"><a href="#终端解：z-l时，条件已知" class="headerlink" title="终端解：z=l时，条件已知"></a>终端解：z=l时，条件已知</h4><p>我只求终端解，其他解都一样<br>已知：$V(l)=V_L,I(l)=I_L$<br>为方便求解设:$d=l-z$这里+d方向就是向电源方向（即-z方向）<br>得<br>$$<br>\left[<br>    \begin{matrix}<br>    V(d)\<br>    I(d)<br>    \end{matrix}<br>\right]=<br>\left[<br>    \begin{matrix}<br>    ch; \gamma d&amp;Z_0sh; \gamma d\<br>    \frac{sh; \gamma d}{Z_0}&amp;ch ; \gamma d<br>    \end{matrix}<br>\right]<br>\left[<br>    \begin{matrix}<br>    V_L\<br>    I_L<br>    \end{matrix}<br>\right]<br>$$</p>
<h3 id="2-特性阻抗，传播常数的定义"><a href="#2-特性阻抗，传播常数的定义" class="headerlink" title="2. 特性阻抗，传播常数的定义"></a>2. 特性阻抗，传播常数的定义</h3><p>特性阻抗：$Z_0=\sqrt{\frac{R+j\omega L_1}{G+j\omega C}}$<br>一般情况下是个复数，如果其与频率无关，则为纯电;如果是无耗线则$Z_0=\sqrt{L/C}$<br>传播常数，描绘导行波传播过程中 的衰减（实部）和相位变化（虚部）：$\gamma =\sqrt{(R+j\omega L_1)(G+j\omega C)}=\alpha +j\beta$<br>对无耗线：$\alpha =0,\beta =\omega \sqrt{LC}$</p>
<h3 id="3-任一点的输入阻抗的定义及性质，会计算。（半波长重复性，四分之一波长变换性）"><a href="#3-任一点的输入阻抗的定义及性质，会计算。（半波长重复性，四分之一波长变换性）" class="headerlink" title="3. 任一点的输入阻抗的定义及性质，会计算。（半波长重复性，四分之一波长变换性）"></a>3. 任一点的输入阻抗的定义及性质，会计算。（半波长重复性，四分之一波长变换性）</h3><p>输入阻抗$Z_{in}(d)=\frac{V(d)}{I(d)}$，对无耗线<br>$Z_{in}(d)=Z_0\frac{Z_L+Z_0tg; \beta d}{Z_0+Z_Ltg; \beta d}$<br>则对无耗线而言有：</p>
<ol>
<li>$\lambda /4$的变换性：$Z_{in}(d+\lambda /4)=\frac{Z_0^2}{Z_{in}}$</li>
<li>$\lambda /2$的不变：$Z_{in}(d+\lambda /2)=Z_{in}(d)$</li>
</ol>
<h3 id="4-反射参量定义表达式。（电压反射系数定义式，任一点反射系数与重大-UN反射系数的关系，重点是无耗线）"><a href="#4-反射参量定义表达式。（电压反射系数定义式，任一点反射系数与重大-UN反射系数的关系，重点是无耗线）" class="headerlink" title="4. 反射参量定义表达式。（电压反射系数定义式，任一点反射系数与重大 UN反射系数的关系，重点是无耗线）"></a>4. 反射参量定义表达式。（电压反射系数定义式，任一点反射系数与重大 UN反射系数的关系，重点是无耗线）</h3><p>定义电压反射系数$\Gamma_v(d)=\frac{V^-(d)}{V^+(d)}$<br>负号表示反射波，一般的话是+d方向（远离负载方向）也就是-z（注意具体情况具体分析）<br>希望还记得那个终端解,<br>$$<br>\Gamma_v(d)=\frac{((V_L-Z_0I)/2)e^{-\gamma d}}{((V_L+Z_0I)/2)e^{\gamma d}}=\frac{Z_L-Z_0}{Z_L+Z_0}e^{-2\gamma d}\<br>\Gamma_L=\frac{Z_L-Z_0}{Z_L+Z_0}=|\Gamma_L|e^{j\psi}\<br>\rightarrow \Gamma_v(d)=|\Gamma_L|e^{j\psi -2(\alpha +j\beta )d}<br>$$<br>考虑无耗线(有耗线其实就是加个衰减系数)<br>$\Gamma_v(d)=|\Gamma_L|e^{j(\psi -2\beta d)}$</p>
<h3 id="5-反射参量与输入阻抗的关系"><a href="#5-反射参量与输入阻抗的关系" class="headerlink" title="5. 反射参量与输入阻抗的关系"></a>5. 反射参量与输入阻抗的关系</h3><p>$$<br>Z_in(d)=Z_0\frac{1+\Gamma_v(d)}{1-\Gamma_v(d)}\<br>\Gamma_v(d)=\frac{Z_in(d)-Z_0}{Z_in(d)+Z_0}<br>$$<br>上定义即可</p>
<h3 id="6-驻波比和行波系数的定义。（波节点，波腹点阻抗的大小）"><a href="#6-驻波比和行波系数的定义。（波节点，波腹点阻抗的大小）" class="headerlink" title="6. 驻波比和行波系数的定义。（波节点，波腹点阻抗的大小）"></a>6. 驻波比和行波系数的定义。（波节点，波腹点阻抗的大小）</h3><p>驻波比：$\rho =\frac{|V|<em>{max}}{|V|</em>{min}}=\frac{1+|T_L|}{1-|T_L|}$<br>推出和反射系数的方法就是，把终端解换成用反射系数去表示的，然后求模<br>行波系数就是驻波比取个倒数</p>
<h3 id="7-无耗线的三种工作状态特点。（工作条件，线上的电压、电流、阻抗分布特点，特别是终端短路，终端开路的情况，短路线和开路线的阻抗大小等）"><a href="#7-无耗线的三种工作状态特点。（工作条件，线上的电压、电流、阻抗分布特点，特别是终端短路，终端开路的情况，短路线和开路线的阻抗大小等）" class="headerlink" title="7. 无耗线的三种工作状态特点。（工作条件，线上的电压、电流、阻抗分布特点，特别是终端短路，终端开路的情况，短路线和开路线的阻抗大小等）"></a>7. 无耗线的三种工作状态特点。（工作条件，线上的电压、电流、阻抗分布特点，特别是终端短路，终端开路的情况，短路线和开路线的阻抗大小等）</h3><p>emem，这个就大略一提吧，公式就少写，但是 这块就真的很重要！！！！</p>
<ol>
<li>行波状态：无反射<br>无反射，反射系数就为0,驻波比为1,条件$Z_L=Z_0 \rightarrow Z_{in}=Z_0$<br>各点幅值相等</li>
<li>驻波：全反射<br>负载短路时，哎呀算了$Z_{in}^{sc}(d)=jZ_0tg; \beta d$，且此时负载为电压最小点<br>负载开路路时，哎呀算了$Z_{in}^{oc}(d)=-jZ_0ctg; \beta d$，且此时负载为电压最大点,上面那个变换性<br>有$Z_0=\sqrt{Z_{in}^{oc}Z_{in}^{sc}}$<br>接纯电抗<br>其实就是归一化斯密斯图<br>$l=\frac{\lambda}{2\pi}arctg(\frac{X_L}{Z_0})$</li>
<li>行驻波：$Z_L=R_L+JX_L$<br>我就写一个：<br>$$<br>|V|<em>{max}=|V_L^+|+[1+|T_L|],V_L^+=\frac{V_L+I_LZ_0}{2}e^{\gamma d}\<br>d</em>{max}=\frac{\lambda}{4\pi}\psi\<br>R_{max}=Z_0\rho\<br>R_{max}R_{min}=Z_0^2<br>$$</li>
</ol>
<h3 id="8-史密斯圆图的依据关系式2"><a href="#8-史密斯圆图的依据关系式2" class="headerlink" title="8. 史密斯圆图的依据关系式2"></a>8. 史密斯圆图的依据关系式2</h3><p>用归一化阻抗和反射系数，求虚部和实部</p>
<h3 id="9-圆图上的三个圆的表达式。（不需要记住表达式，目的：明确圆图中圆和相应弧线的含义）"><a href="#9-圆图上的三个圆的表达式。（不需要记住表达式，目的：明确圆图中圆和相应弧线的含义）" class="headerlink" title="9. 圆图上的三个圆的表达式。（不需要记住表达式，目的：明确圆图中圆和相应弧线的含义）"></a>9. 圆图上的三个圆的表达式。（不需要记住表达式，目的：明确圆图中圆和相应弧线的含义）</h3><p>明确！！</p>
<h3 id="11-圆图上三个特殊点，两个特殊线，两个旋转方向。（使用圆图基础）"><a href="#11-圆图上三个特殊点，两个特殊线，两个旋转方向。（使用圆图基础）" class="headerlink" title="11. 圆图上三个特殊点，两个特殊线，两个旋转方向。（使用圆图基础）"></a>11. 圆图上三个特殊点，两个特殊线，两个旋转方向。（使用圆图基础）</h3><p>明确！！</p>
<h3 id="12-λ-4-的波长匹配器的计算（终端为非电阻型阻抗的情况该如何处理），单、双枝节匹配会用圆图求解（掌握求解步骤）"><a href="#12-λ-4-的波长匹配器的计算（终端为非电阻型阻抗的情况该如何处理），单、双枝节匹配会用圆图求解（掌握求解步骤）" class="headerlink" title="12. λ/4 的波长匹配器的计算（终端为非电阻型阻抗的情况该如何处理），单、双枝节匹配会用圆图求解（掌握求解步骤）"></a>12. λ/4 的波长匹配器的计算（终端为非电阻型阻抗的情况该如何处理），单、双枝节匹配会用圆图求解（掌握求解步骤）</h3><p>明确！！你要干啥，就是要落在$r=1,x=0$上</p>
<h2 id="第三章-金属波导"><a href="#第三章-金属波导" class="headerlink" title="第三章 金属波导"></a>第三章 金属波导</h2><h3 id="1-矩形波导，圆波导各自的主模，单模传输条件"><a href="#1-矩形波导，圆波导各自的主模，单模传输条件" class="headerlink" title="1. 矩形波导，圆波导各自的主模，单模传输条件"></a>1. 矩形波导，圆波导各自的主模，单模传输条件</h3><ol>
<li>矩形波导：<br>$$<br>TE_{10}:H_z、H_x、E_y\<br>\lambda_c=2a,f_c=\frac{v}{\lambda_c},k_c^2=(\frac{\pi}{a})^2\<br>a&lt;\lambda &lt;2a,\lambda &lt;2b<br>$$</li>
<li>圆形波导：<br>$$<br>TE_{11}:H_z、H_r、H_{\Phi}、E_r、E_{\Phi}\<br>\lambda_c=2\pi a/u_{11}^{‘},f_c=\frac{v}{\lambda_c},k_c^2=(\frac{u_{11}^{‘}}{a})^2\<br>$$</li>
</ol>
<h3 id="2-在矩形波导和圆波导中-TE-mn-、TM-mn-模的场结构如何描述，即波形指数m、n的含义"><a href="#2-在矩形波导和圆波导中-TE-mn-、TM-mn-模的场结构如何描述，即波形指数m、n的含义" class="headerlink" title="2. 在矩形波导和圆波导中$TE_{mn}、TM_{mn}$模的场结构如何描述，即波形指数m、n的含义"></a>2. 在矩形波导和圆波导中$TE_{mn}、TM_{mn}$模的场结构如何描述，即波形指数m、n的含义</h3><p>矩形波导：中m和n分别代表场强沿x轴和y轴方向分布的半波数。<br>圆形波导：<br>m代表沿圆周φ分布的整驻波数；<br>n代表沿半径r分布场的最大值个数（TE、TM都是）</p>
<h3 id="3-矩形波导的传输特性。传输常数，截止波长，截止频率，传播条件，相速度，群速度，波导波长，波阻抗（-TE-mn-、TM-mn-模不同）"><a href="#3-矩形波导的传输特性。传输常数，截止波长，截止频率，传播条件，相速度，群速度，波导波长，波阻抗（-TE-mn-、TM-mn-模不同）" class="headerlink" title="3. 矩形波导的传输特性。传输常数，截止波长，截止频率，传播条件，相速度，群速度，波导波长，波阻抗（$TE_{mn}、TM_{mn}$模不同）"></a>3. 矩形波导的传输特性。传输常数，截止波长，截止频率，传播条件，相速度，群速度，波导波长，波阻抗（$TE_{mn}、TM_{mn}$模不同）</h3><p>矩形波导TE中mn不能同时为0,TM中mn不能为0.<br>$$<br>\beta_{mn}=\sqrt{(k)^2-(\frac{m\pi}{a})^2-(\frac{n\pi}{b})^2}\<br>k_{cmn}^2=(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2\<br>f_{cmn}=\frac{k_{cmn}}{2\pi \sqrt{\mu\epsilon}}\<br>\lambda_{cmn}=\frac{2\pi}{k_{cmn}}\<br>g=\sqrt{1-(\frac{\lambda}{\lambda_{cmn}})^2}\<br>v_p=v/g,v_g=vg\<br>\lambda_g=\lambda/g\<br>Z_{TEmn}=\eta /g\<br>Z_{TM_{mn}}=\eta g<br>$$</p>
<h3 id="4-矩形波导，圆波导中典型模式的场表达式（比如矩形波导-TE10，圆形波导的TE01，TM01等，主要搞清楚纵向场的关系）"><a href="#4-矩形波导，圆波导中典型模式的场表达式（比如矩形波导-TE10，圆形波导的TE01，TM01等，主要搞清楚纵向场的关系）" class="headerlink" title="4. 矩形波导，圆波导中典型模式的场表达式（比如矩形波导 TE10，圆形波导的TE01，TM01等，主要搞清楚纵向场的关系）"></a>4. 矩形波导，圆波导中典型模式的场表达式（比如矩形波导 TE10，圆形波导的TE01，TM01等，主要搞清楚纵向场的关系）</h3><h3 id="5-矩形波导中的波形简并，圆形波导中的两种不同简并形式，解释其区别"><a href="#5-矩形波导中的波形简并，圆形波导中的两种不同简并形式，解释其区别" class="headerlink" title="5. 矩形波导中的波形简并，圆形波导中的两种不同简并形式，解释其区别"></a>5. 矩形波导中的波形简并，圆形波导中的两种不同简并形式，解释其区别</h3><p>矩形波导的简并是：$\lambda_{cTE_{mn}} =\lambda_{cTM_{mn}}$<br>圆形波导的简并是：1.$m\neq 0$时，$TE_{mn},TM_{mn}$的极化简并2.$\lambda_{cTE_{0n}} =\lambda_{cTM_{1n}}$</p>
<h3 id="6-圆波导中截止波长，截止频率和传播常数的计算公式"><a href="#6-圆波导中截止波长，截止频率和传播常数的计算公式" class="headerlink" title="6. 圆波导中截止波长，截止频率和传播常数的计算公式"></a>6. 圆波导中截止波长，截止频率和传播常数的计算公式</h3><p>$$<br>TE_{mn}:k_{cmn}=\frac{u_{mn}^{‘}}{a},\lambda_{cmn}=\frac{2\pi}{k_{cmn}}==\frac{2a\pi}{u_{mn}^{‘}}\<br>TM_{mn}:k_{cmn}=\frac{u_{mn}}{a},\lambda_{cmn}=\frac{2\pi}{k_{cmn}}==\frac{2a\pi}{u_{mn}}<br>$$<br>$u_{mn}^{‘}$m阶Bessel函数的导数的第n个根<br>$u_{mn}$m阶Bessel函数的第n个根</p>
<h3 id="7-同轴线主要传输的模式：TEM模"><a href="#7-同轴线主要传输的模式：TEM模" class="headerlink" title="7. 同轴线主要传输的模式：TEM模"></a>7. 同轴线主要传输的模式：TEM模</h3><h3 id="8-保证同轴线只传输主模的条件"><a href="#8-保证同轴线只传输主模的条件" class="headerlink" title="8. 保证同轴线只传输主模的条件"></a>8. 保证同轴线只传输主模的条件</h3><p>$\lambda_{min} &gt; (a+b)\pi$</p>
<h2 id="第四章-微带线和带状线"><a href="#第四章-微带线和带状线" class="headerlink" title="第四章 微带线和带状线"></a>第四章 微带线和带状线</h2><ol>
<li>带状线的场结构。（会画简单示意图）</li>
<li>带状线的工作模式，传输 TEM 波。</li>
<li>微带线的场结构。（会画简单示意图）</li>
<li>微带线中的工作模式。混合的 TE－TM 模式，准 TEM 模。一般写准TEM波</li>
<li>微带线传输介质基片一定，导带宽度W越宽，微带线的特性阻抗越小</li>
</ol>
<h2 id="第五章-介质波导和介质谐振器"><a href="#第五章-介质波导和介质谐振器" class="headerlink" title="第五章 介质波导和介质谐振器"></a>第五章 介质波导和介质谐振器</h2><ol>
<li>介质板波导中场与金属波导的区别，截止条件<br>介质波导中传播的是<strong>表面波</strong>（慢波），被束缚在波导内和波导表面。<br>介质板内波形要求为振荡波型，板外要求为衰减波型，截止条件为波向介质的横向方向辐射，即再横向方向形成了辐射模，$\alpha_s=0$或$\beta^2=\omega^2***$略过，金属波导的截止条件是纵向方向出现了衰减模，$\beta=0$</li>
<li>圆形介质波导中的模式<br>不支持纯$TM_{mn}、TE_{mn}$，支持$TM_{0n}、TE_{0n}$,一般存在$EH_{mn}、HE_{mn}$，主模为$HE_{11}$</li>
<li>介质谐振器实例分析。<br>置于一段截止波导中的谐振器，它与传输波导之间的耦合程度取决于两者之间的距离l，改变l就可以调节耦合的大小</li>
<li>圆形介质谐振器中的模式，和波形指数的含义。与金属谐振腔对比记忆<br>圆柱型介质谐振器，这里上个图好了<br><img src="https://i.loli.net/2021/06/08/CR2nbHqrUJlmgiD.png" alt="圆柱型介质谐振器"></li>
</ol>
<h2 id="第六章-微波网络基础"><a href="#第六章-微波网络基础" class="headerlink" title="第六章 微波网络基础"></a>第六章 微波网络基础</h2><ol>
<li>阻抗矩阵、导纳矩阵元素的定义及含义。<br>$Z_{ij}=\frac{V_i}{I_j}|<em>{I_k=0,k\neq j}$含义：其它所有端口都开路的情况下从端口j到端口i的转移阻抗<br>$Y</em>{ij}=\frac{I_i}{V_j}|<em>{V_k=0,k\neq j}$含义：其它所有端口都短路的情况下从端口j到端口i的转移导纳<br>$Z</em>{ii}=\frac{V_i}{I_i}|<em>{I_k=0,k\neq i}$含义：其它所有端口都开路的情况下从端口i看过去的输入阻抗<br>$Y</em>{ii}$同理</li>
<li>转移矩阵，散射矩阵的各元素的定义及含义。<br>先散射矩阵，即S矩阵。微波中电压电流没有明确物理意义。设对端口而言反射波为$b_k$，入射波为$a_k$，且是已经归一化了。<br>提一嘴（还是挺重要的）：$v_i=\frac{V_i}{\sqrt{Z_{0i}}},i_i={I_i}{\sqrt{Z_{0i}}}$<br>$S_{ij}=\frac{b_i}{a_j}|<em>{a_k=0,k\neq j}$含义：其它所有端口都匹配(即端口的负载无反射波,对负载而言反射波为$a_k$)的情况下从端口j到端口i的传输系数<br>$S</em>{ii}=\frac{b_i}{a_i}|<em>{b_k=0,k\neq j}$含义：其它所有端口都匹配(即端口无反射波)的情况下从端口i的反射系数<br>对一二端口网络有：$\Gamma</em>{in}=S_{11}+\frac{S_{12}S_{21}\Gamma_L}{1-S_{22}\Gamma_L}$<br>对线性互易网络负载匹配，开路，短路即可解出$S_{11},S_{22},S_{21}=S_{12}$<br>转移矩阵ABCD：对二端口网络<br>$$<br>\left{<br>\begin{array}{c}<br>V_1=AV_2+BI_2\<br>I_1=CV_2+DI_2<br>\end{array}<br>\right.<br>\<br>\left[<br> \begin{matrix}<br> A&amp;B\<br> C&amp;D<br> \end{matrix}<br>\right]<br>$$</li>
<li>无耗网络，互易网络 散射矩阵性质，参考面平移对矩阵元素影响。<br>阻抗，导纳：互易：对称;无耗：纯虚数<br>散射矩阵特性：<br>如果网络是互易的，则矩阵是对称的：$[S]^t=[S]$<br>如果网络是无耗的，则矩阵满足幺正性：$[S]^t[S]^*=[E]$<br>如果二端口网络是对称的，则满足：$S_{11}=S_{22}$<br>线性互易无耗的二端口网络有：$|S_{11}|=|S_{22}|=\sqrt{1-|S_{12}|^2},\theta_{12}-(\theta_{11}+\theta_{22})=\pm \pi$<br>参考面向外移动（远离负载j方向，比如左边是负载，右边是端口，远离就是向右动）$l_i$，记$\theta_j=2\pi l_j/\lambda_{gj}$<br>入射波超前+，反射波滞后-（相位看谁先到0谁超前），有<br>$$<br>[S^{‘}]=[P][S][P]<br>\<br>[P]=\left[<br> \begin{matrix}<br> e^{-\jmath \theta_1}&amp;0&amp;\cdots &amp;0\<br> 0&amp;e^{-\jmath \theta_2}&amp;\cdots &amp;0\<br> 0&amp;0&amp;\cdots &amp;e^{-\jmath \theta_n}<br> \end{matrix}<br>\right]<br>$$</li>
<li>转移矩阵和散射矩阵的转化关系。（主要是如何由转移矩阵获得散射矩阵）<br>先求归一化abcd，然后套公式</li>
<li>常用二端口网络的转移矩阵和散射矩阵的计算（为计算复杂结构准备）</li>
<li>插入损耗和插入相移的定义。<br>$L_I=10lg\frac{P_{Lb}}{P_{La}}(dB)$<br>在信号内阻和负载都匹配时<br>$L_I=-10lg|S_{21}|^2$<br>$\theta_I=\theta_b-\theta_a$ 正值说明引起相位落后</li>
</ol>
<h2 id="第七章-微波谐振器"><a href="#第七章-微波谐振器" class="headerlink" title="第七章 微波谐振器"></a>第七章 微波谐振器</h2><ol>
<li>谐振器的含义，特点<br>微波谐振器通常由一定形状的“电壁”或“磁壁”限定的体积内，产生电磁振荡。<br>它是一种储能和选频谐振元件，用于滤波器、振荡器、频率计、调谐放大器等。<br>特点：一、多谐性：微波谐振器可以存在无穷多不同振荡模式的自由振荡不同振荡模式具有不同的振荡频率;二、对某一模式，电场和磁场相位相差$\frac{\pi}{2}$，两者最大储能相等。</li>
<li>谐振器的基本参数和定义式。（主要是谐振波长，品质因数）<br>$$<br>l=\frac{p\lambda_g}{2}\quad p=1,2,3,\cdots \<br>\lambda_0=\frac{1}{\sqrt{\frac{1}{\lambda_c^2}+\frac{1}{\lambda_p^2}}}\<br>Q=2\pi \frac{W}{W_T}=\omega_0\frac{W}{P_l}<br>$$</li>
<li>谐振器的最大电能储能和最大磁能储能表达式和关系。<br>$W_e=W_m=\frac{1}{2}\int_ve|E|^2dv=\frac{1}{2}\int_v\mu|H|^2dv$<br>一周期内的平均则再取0.5</li>
<li>串联和并联谐振电路的品质因数表达式及它们分别与 R 的关系<br>串联：$Q=\frac{\omega_0L}{R}=\frac{1}{\omega_0RC}$<br>并联：$Q=\frac{R}{\omega_0L}=\omega_0RC$</li>
<li>金属谐振腔工作模式，最低次模，谐振频率。简单模式的场表达式（与金属波导对比）。<br>矩形波导谐振腔：<br>$$<br>k_c^2=(\frac{m\pi}{a})^2+(\frac{n\pi}{b})^2 \<br>\beta_{mn}=\frac{p\pi}{l} \quad p=1,2,3,\cdots \<br>k_{mnp}^2 = k_c^2+\beta_{mn}^2 \<br>f_{mnp}=\frac{v}{\lambda_0}=\frac{vk_{mnp}}{2\pi}<br>$$<br>主模为$TE_{101}$，与金属波导进行对比差异<br>$$<br>E_y=***sin\frac{p\pi z}{l}\<br>H_X=***cos\frac{p\pi z}{l}\<br>H_z=***sin\frac{p\pi z}{l}\<br>\lambda_{10p}=\frac{2al}{\sqrt{(pa)^2+l^2}}<br>$$<br>圆形波导谐振腔：与圆形波导类似，把$\beta$换为驻波条件即可</li>
</ol>
<h2 id="第八章-常用微波元件"><a href="#第八章-常用微波元件" class="headerlink" title="第八章 常用微波元件"></a>第八章 常用微波元件</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/23/Bilibili%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%87%E5%BC%B9%E5%B9%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/23/Bilibili%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%87%E5%BC%B9%E5%B9%95/" class="post-title-link" itemprop="url">Bilibili屏蔽中文弹幕</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-23 22:42:27" itemprop="dateCreated datePublished" datetime="2021-05-23T22:42:27+08:00">2021-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在观看视频时，为了学习英语，需要观看热心字幕菌留下的弹幕，但是，出现的中文弹幕一定程度上影响了观看学习。</p>
<hr>
<h2 id="使用正则表达式屏蔽中文弹幕"><a href="#使用正则表达式屏蔽中文弹幕" class="headerlink" title="使用正则表达式屏蔽中文弹幕"></a>使用正则表达式屏蔽中文弹幕</h2><p>开启屏蔽-&gt;屏蔽管理-&gt;正则</p>
<pre><code>/[\u4e00-\u9fa5]/
</code></pre>
<p>Over！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/LongestCommonSubsequenceProblem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/LongestCommonSubsequenceProblem/" class="post-title-link" itemprop="url">最长公共子序列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-18 13:40:39" itemprop="dateCreated datePublished" datetime="2021-04-18T13:40:39+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>子序列：序列$X_n=&lt;x_1,\dots ,x_n&gt;,Z_k=&lt;z_1,\dots ,z_k&gt;$，当存在一个严格递增的X的下标序列$&lt;i_1,\dots ,i_k&gt;$，对所有$j=1,2,\dots,k$，满足$x_{i_j}=z_j$，称$Z_k$为$X_n$的一个子序列。</li>
<li>公共子序列对序列X、Y，序列Z是他们的子序列，Z为X、Y的公共子序列。</li>
</ol>
<p>那么给定两个序列X，Y，求其最长的公共子序列。</p>
<h2 id="刻画最优解的结构特征"><a href="#刻画最优解的结构特征" class="headerlink" title="刻画最优解的结构特征"></a>刻画最优解的结构特征</h2><p>子问题对应序列前缀的最长公共子序列。</p>
<h3 id="给出最长公共子序列的定理"><a href="#给出最长公共子序列的定理" class="headerlink" title="给出最长公共子序列的定理"></a>给出最长公共子序列的定理</h3><p>对$X_m,Y_n$，最长公共子序列为$Z_k$</p>
<p>$$1.x_m=y_n\Rightarrow z_k=x_m=y_n,Z_{k-1}是X_{m-1},Y_{n-1}的最长公共子序列\ 2.x_m\neq y_n,z_k\neq x_m \Rightarrow Z_k是X_{m-1},Y_n的最长公共子序列 \ 3.x_m\neq y_n,z_k\neq y_n \Rightarrow Z_k是X_m,Y_{n-1}的最长公共子序列$$</p>
<p>可以用反证法证明结论的正确性，如1.若$Z_{k-1}$不是满足要求最长的公共子序列，那有另一个W序列为最长公共子序列，W中再加入一项就为$X_m,Y_n$的最长公共子序列，但不为$Z_{k-1}$，故矛盾。</p>
<h2 id="递归定义最优解的值"><a href="#递归定义最优解的值" class="headerlink" title="递归定义最优解的值"></a>递归定义最优解的值</h2><p>最优解的值为最长公共子序列的长度：关键。</p>
<p>按照定理找出递推式子，定义$c[m,n]=Z_k.Length$ 有：</p>
<p>$$c[i,j]=<br>\begin{cases}<br>0,\quad i=j=0 \<br>c[i-1,j-1]+1,\quad x_i=y_j,i\gt 0,j\gt 0 \<br>max\lbrace c[i-1,j],c[i,j-1]\rbrace,\quad x_i\neq y_j,i\gt 0,j\gt 0<br>\end{cases}$$</p>
<p>反映出子问题的重叠性</p>
<h2 id="计算最优解的值"><a href="#计算最优解的值" class="headerlink" title="计算最优解的值"></a>计算最优解的值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCSLength</span><span class="params">(<span class="built_in">string</span> X, <span class="built_in">string</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **c = <span class="keyword">new</span> <span class="keyword">int</span> *[X.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= X.length(); ++i)</span><br><span class="line">        c[i] = <span class="keyword">new</span> <span class="keyword">int</span>[Y.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= X.length(); ++i)</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Y.length(); ++i)</span><br><span class="line">        c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= X.length(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Y.length(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c[i][j] = max(c[i - <span class="number">1</span>][j], c[i][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> c[X.length()][Y.length()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> X = <span class="string">&quot;ABCBDAB&quot;</span>, Y = <span class="string">&quot;BDCABA&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; LCSLength(X, Y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度：$O(nm)$，时间复杂度：$O(nm)$</p>
<p>考虑一个空间复杂度为：$min(n,m)$的算法，考虑到其实每次只使用了这一行和上一行的结果，考虑用两个数组存储这一行的结果和上一行的结果即可，数组长度应该为列的长度，即Y的长度。考虑到最小，可以考虑比较序列长度后，使得行的长度总是为最大。</p>
<p><img src="LongestCommonSubsequenceProblem(LCS)%204f2996c538244eb889418f9f5a8ef2f8/Screenshot_2021-04-14_at_12.57.53_PM.png" alt="LongestCommonSubsequenceProblem(LCS)%204f2996c538244eb889418f9f5a8ef2f8/Screenshot_2021-04-14_at_12.57.53_PM.png"></p>
<p><img src="LongestCommonSubsequenceProblem(LCS)%204f2996c538244eb889418f9f5a8ef2f8.png" alt="LongestCommonSubsequenceProblem(LCS)%204f2996c538244eb889418f9f5a8ef2f8.png"></p>
<p>$$cur[j]=<br>\begin{cases}<br>pre[j-1]+1,\quad x_i=y_j\<br>max(pre[j]+cur[j-1]),\quad x_i\neq y_j<br>\end{cases}$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCSLength</span><span class="params">(<span class="built_in">string</span> X, <span class="built_in">string</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minLen = min(X.length(), Y.length());</span><br><span class="line">    <span class="keyword">if</span> (minLen == X.length())</span><br><span class="line">        swap(X, Y);</span><br><span class="line">    <span class="keyword">int</span> *cur = <span class="keyword">new</span> <span class="keyword">int</span>[minLen + <span class="number">1</span>], *pre = <span class="keyword">new</span> <span class="keyword">int</span>[minLen + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= minLen; ++i)</span><br><span class="line">        cur[i] = <span class="number">0</span>, pre[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= X.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Y.length(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])</span><br><span class="line">                cur[j] = pre[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur[j] = max(pre[j], cur[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= minLen; ++k)</span><br><span class="line">            pre[k] = cur[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[minLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构最优解"><a href="#重构最优解" class="headerlink" title="重构最优解"></a>重构最优解</h2><p>如果使用第一种方法，那么二维数组c中已经拥有能够重构最优解的信息了。如果使用了第二种方法，cur以及pre的信息还不足够重构最优解，需要再引入一个二维数组b，记录路线。</p>
<h3 id="引入数组b"><a href="#引入数组b" class="headerlink" title="引入数组b"></a>引入数组b</h3><p>先看简单的。重构解可以考虑递归算法，从终点跑回原点出求出最大公共子序列，$b[i][j]=1$代表$X_{i-1}=Y_{j-1}$，即X，Y都包含的元素，则输出，但是注意的是应该先递归到底部在考虑输出，所以先继续递归。$b[i][j]=2$代表LCS在$X_{i-1},Y_{j}$即还要继续寻找。3同理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLCS</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> **b, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i * j))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b[i][j] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintLCS(A, b, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; A[i - <span class="number">1</span>];<span class="comment">//传入Y则输出A[j-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b[i][j] == <span class="number">2</span>)</span><br><span class="line">        PrintLCS(A, b, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PrintLCS(A, b, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCSLength</span><span class="params">(<span class="built_in">string</span> X, <span class="built_in">string</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minLen = min(X.length(), Y.length());</span><br><span class="line">    <span class="keyword">if</span> (minLen == X.length())</span><br><span class="line">        swap(X, Y);</span><br><span class="line">    <span class="keyword">int</span> *cur = <span class="keyword">new</span> <span class="keyword">int</span>[minLen + <span class="number">1</span>], *pre = <span class="keyword">new</span> <span class="keyword">int</span>[minLen + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> **b = <span class="keyword">new</span> <span class="keyword">int</span> *[X.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= X.length(); ++i)</span><br><span class="line">        b[i] = <span class="keyword">new</span> <span class="keyword">int</span>[Y.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= minLen; ++i)</span><br><span class="line">        cur[i] = <span class="number">0</span>, pre[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= X.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Y.length(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                cur[j] = pre[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                b[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pre[j] &gt;= cur[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                cur[j] = pre[j];</span><br><span class="line">                b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur[j] = cur[j - <span class="number">1</span>];</span><br><span class="line">                b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= minLen; ++k)</span><br><span class="line">            pre[k] = cur[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintLCS(X, b, X.length(), Y.length());<span class="comment">//也可以传Y</span></span><br><span class="line">    <span class="keyword">return</span> cur[minLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-i-j-重构解"><a href="#c-i-j-重构解" class="headerlink" title="c[i][j]重构解"></a>c[i][j]重构解</h3><p>二维数组c中已经拥有能够重构最优解的信息了，有了上面的例子，其实就是用c去代替b的作用。改一下PrintLCS即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLCS</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> **b, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i * j))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b[i][j] == (b[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintLCS(A, b, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; A[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b[i][j] == (b[i<span class="number">-1</span>][j]))</span><br><span class="line">        PrintLCS(A, b, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PrintLCS(A, b, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>求一个n个数的序列的最长单调递增序列。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/CutRod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MH's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/CutRod/" class="post-title-link" itemprop="url">钢条切割</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-18 13:40:10" itemprop="dateCreated datePublished" datetime="2021-04-18T13:40:10+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 20:04:16" itemprop="dateModified" datetime="2021-09-09T20:04:16+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一段长度为i的钢条的价格$p_i$，那么给定一段长为n的钢条和价格表p，求最佳的切割方案使得出售价格最高。</p>
<h3 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解"></a>递归求解</h3><p>长为n的钢条，每段长度为1的一端总有两种方案，切与不切，则我们有$2^{n-1}$种切割方案。</p>
<p>切割方案，以及售价$r_n$可表示为</p>
<p>$$n=i_1+i_2+\dots +i_k \ r_n = \sum_{j=1}^{k}p_{i_j} \ \rightarrow ; r_n = max(p_n,r_1+r_{n-1},r_2+r_{n-2},\dots,r_{n-1}+r_{1})$$</p>
<p>售价$r_n$就表示为长度为n的钢铁的最高售价，其等价于$r_n = max_{1\le i \le n}(p_i+r_{n-i})$</p>
<p>由此我们得到了一个递归式，注意到$r_0 = 0$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CutRod</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归求解</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = INT32_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q = max(q, p[i] + CutRod(p, n - i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>效率很差，因为，CutRod会反复求解已经求解过的值，如i=2时，会求解：i=1,i=0，然后比较后求得i=2的解，但并未保存，而后i=3,又要重新求解i=2,i=1,i=0,再比较后求得i=3。其时间复杂度递归式：</p>
<p>$$T(n)=1+\sum_{i=0}^{n-1}T(i) \ T(0)=1 \ \because T(n-1)=1+\sum_{i=0}^{n-2}T(i) \ \therefore T(n)-T(n-1)=T(n-1) \Rightarrow T(n)=2^n$$</p>
<h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><h4 id="带备忘的自顶向下"><a href="#带备忘的自顶向下" class="headerlink" title="带备忘的自顶向下"></a>带备忘的自顶向下</h4><p>递归求解之所以效率很慢，因为没有保存已经求解过的子问题的解，为改进，我们就在求解前先检查是否已经求解过解，那么我们就需要额外的空间去储存这些解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MemoizedCutRod</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//从0-n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        r[i] = INT32_MIN;</span><br><span class="line">    <span class="keyword">return</span> MemoizedCutRodAux(p, r, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MemoizedCutRodAux</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *r, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[n] &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r[n]; <span class="comment">//考虑到收益总是非负值,r[n]ge0说明r[n]已经被记录了直接返回</span></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q = max(q, p[i] + MemoizedCutRodAux(p, r, n - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[n] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h4><p>我们先求解最小的问题，再一步步往上求解更大的问题。$r_n = max_{1\le i \le n}(p_i+r_{n-i})$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BottomUpCutRod</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//n=0,售价为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = INT32_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            q = max(q, p[j] + r[i - j]);</span><br><span class="line">        r[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这两种方法的时间复杂度都为$\Theta (n^2)$</p>
<h3 id="重规划"><a href="#重规划" class="headerlink" title="重规划"></a>重规划</h3><p>上面的动态规格只给出了最高售价，未给出切割方案。为了得到切割方案，我们应该去存储得到最高售价时的切割方案</p>
<p>先考虑自底向上的方法</p>
<p>s的确定应该实在q改变时，只要修改一下 <code>q = max(q, p[j] + r[i - j]);</code> 即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ExtendedBottomUpCutRod</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *s = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span>, s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = INT32_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &lt; p[j] + r[i - j])</span><br><span class="line">            &#123;</span><br><span class="line">                q = p[j] + r[i - j];</span><br><span class="line">                s[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i:     &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;r[i]:  &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;s[i]:  &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[i] &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> r[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑自顶向下的方法，也是找到q改变的时候记录一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MemoizedCutRodAux</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *r, <span class="keyword">int</span> *s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[n] &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r[n]; <span class="comment">//考虑到收益总是非负值,r[n]ge0说明r[n]已经被记录了直接返回</span></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = MemoizedCutRodAux(p, r, s, n - i);</span><br><span class="line">            <span class="keyword">if</span> (q &lt; p[i] + temp)</span><br><span class="line">            &#123;</span><br><span class="line">                q = p[i] + temp;</span><br><span class="line">                s[n] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[n] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mrwatermolen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mrwatermolen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MH</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
